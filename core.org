#+property: tangle core.jo
#+title: core
- syntax for super
- <stack>
- has-method? has-meta-method?
- <table>
* todo

  - fix the root of gc

  - [maybe] (note syntax for (>> name) (<< name) and (> name) (< name))

  - <str>

  - <jojo>

  - to see what <module> needs from <path> and <file>

  - example of the use of oo

  - [emacs]
    - write some emacs-lisp lib
    - bright and dark color theme

  - [testing] assert for embedded testing

  - [maybe] syntax for local helper functions

  - syntax-check by another interpreter written in jojo

* note

*** terminology

    - tag as class-name

*** object

    - object on stack :
      [data tag]

    - object in variable :
      [data tag cons]

*** class

    - class on stack :
      [class (jo <class>)]

*** variable

    - instance-variable or meta-variable

    - variable = [name data tag cons cons]

* flag

  #+begin_src jojo
  (run testing-flag/on)
  (test top-repl/printing-flag/on)
  #+end_src

* list

*** cons

    #+begin_src jojo
    (def cons-size      (data (integer 3) cell-size mul))
    (def cons-area-size (data (integer 1024 1024) mul cons-size mul))
    (def cons-area      (data cons-area-size allocate))
    (def cons-area-top  (data cons-area cons-area-size add))
    (def cons-pointer   (data cons-area))
    (def current-mark   (data (integer 1)))
    (def max-mark       (data (integer 1024 1024) mul))

    (def cons-pointer/next
      (jojo
        (note -> [cons-pointer])
        cons-size cons-pointer add
        (& cons-pointer) set-cell))

    (def cons-pointer/init
      (jojo
        (note -> [cons-pointer])
        cons-area
        (& cons-pointer) set-cell))

    (def cons-pointer/next-free
      (jojo
        (note -> [cons-pointer])
        (if cons-pointer cons-area-top eq? then end)
        (if cons-pointer get-cell current-mark eq? not then end)
        cons-pointer/next
        (loop)))

    (def cons?
      (jojo
        (note cell -> bool)
        (if dup cons-area lt? then drop false end)
        (if dup cons-area-top gteq? then drop false end)
        cons-area sub cons-size mod (integer 0) eq?))



    (declare
     (car (note cons -> cell))
     (cdr (note cons -> cell)))

    (def cons-area/report/loop
      (jojo
        (note cons -> [io])
        (if dup cons-area-top eq? then drop end)
        (string "#:") string/print
        dup dot
        (string "mark: ") string/print
        dup get-cell dot
        (string "car: ") string/print
        dup car dot
        (string "cdr: ") string/print
        dup cdr dot
        newline
        cons-size add
        (loop)))

    (def cons-area/report
      (jojo
        (note -> [io])
        cons-area cons-area/report/loop))



    (def sweep-cons-area/loop
      (jojo
        (note cons -> [io])
        (if dup cons-area-top eq? then drop end)
        dup (integer 0)  swap set-cell
        cons-size add
        (loop)))

    (def sweep-cons-area
      (jojo
        (note -> [cons-area])
        cons-area sweep-cons-area/loop))



    (note root from :
          stack
          def)

    (def mark-cons
      (jojo
        (note cons -> [cons-area])
        (if dup cons? not then drop end)
        dup current-mark swap set-cell
        dup car mark-cons
        cdr (loop)))

    (def mark-cons-area/def-record
      (jojo
        (note def-record -> [cons-area])
        (if dup get-cell (integer 0) eq? then drop end)
        dup get-cell mark-cons
        cell-size add
        (loop)))

    (def mark-cons-area/argument-stack
      (jojo
        (note stack -> [cons-area])
        (if dup stack-base eq? then drop end)
        cell-size sub
        dup get-cell mark-cons
        (loop)))

    (def mark-cons-area
      (jojo
        (note -> [cons-area])
        (if current-mark max-mark eq? then
            sweep-cons-area
            (integer 0) (& current-mark) set-cell)
        current-mark (integer 1) add (& current-mark) set-cell
        def-record mark-cons-area/def-record
        stack-pointer
        mark-cons-area/argument-stack))



    (note cons :
          mark
          car
          cdr)

    (def new/cons
      (jojo
        (note -> cons)
        (if cons-pointer cons-area-top eq? then
            mark-cons-area
            cons-pointer/init
            cons-pointer/next-free
            (if cons-pointer cons-area-top eq? then
                (string "fatal error : cons-area is full") string/print
                newline bye)
            (loop))
        (if cons-pointer get-cell current-mark eq? then
            cons-pointer/next (loop))
        cons-pointer
        cons-pointer/next end))

    (def set-car
      (jojo
        (note cell cons ->)
        cell-size add
        set-cell))

    (def set-cdr
      (jojo
        (note cell cons ->)
        cell-size add
        cell-size add
        set-cell))

    (def car
      (jojo
        (note cons -> cell)
        cell-size add
        get-cell))

    (def cdr
      (jojo
        (note cons -> cell)
        cell-size add
        cell-size add
        get-cell))

    (def cons
      (jojo
        (note cdr-cell car-cell -> cons)
        new/cons
        tuck set-car
        tuck set-cdr))


    (note the following tests are for small cons-area)

    (note (test (integer 0)
                (integer 1) cons
                (integer 2) cons
                dup car dot
                dup cdr car dot
                dup cdr cdr dot

                dup cons? dot
                dup cdr cons? dot
                dup car cons? dot
                dup cdr car cons? dot
                dup cdr cdr cons? dot
                dot

                current-mark
                dot))

    (note (test newline
                new/cons dot
                new/cons dot
                new/cons dot
                new/cons dot
                new/cons dot
                current-mark dot
                newline
                cons-area/report
                newline))
    #+end_src

*** assoc-list

    #+begin_src jojo
    (def assq
      (jojo
        (note assoc-list value -> pair or null)
        (if over null eq? then drop drop null end)
        (if over car cdr over eq? then drop car end)
        swap cdr swap (loop)))

    (def assoc/find
      (jojo
        (note assoc-list value -> [data true] or [false])
        (if over null eq? then drop drop false end)
        (if over car cdr over eq? then drop car true end)
        swap cdr swap (loop)))
    #+end_src

*** list/print

    #+begin_src jojo
    (def list/print
      (jojo
        (note list -> [output])
        (if dup null eq? then drop (jo null) jo/print (string " ") string/print end)
        (if dup cons? not then dot end)
        dup cdr (recur)
        car (recur) (jo cons) jo/print (string " ") string/print))
    #+end_src

*** list/copy

    #+begin_src jojo
    (def list/copy
      (jojo
        (note list -> list)
        (note circles are not handled)
        (if dup cons? then end)
        dup cdr (recur)
        car (recur)
        swap
        cons))

    (note
      (run (integer 1) (integer 2) cons
           (integer 3) null cons
           cons
           dup
           cons
           dup list/print newline
           dup list/copy list/print newline
           dup list/copy list/print newline
           drop))
    #+end_src

*** set-tail

    #+begin_src jojo
    (def set-tail
      (jojo
        (note element list ->)
        (if dup cdr null eq? then
            swap
            null swap cons
            swap
            set-cdr end)
        (el cdr (loop))))
    #+end_src

* [keyword] lev

  #+begin_src jojo
  (def lev
    (note lev denotes leave-data-here)
    (keyword
      read/jo
      (if dup round-ket eq? then drop end)
      (if dup round-bar eq? then drop
          read/jo
          (if dup (jo esc) eq? then
              drop compile-jojo (loop))
          (el jo/apply (jo here) here (loop)))
      (el (jo ins/lit) here
          here
          (jo here) here (loop))))
  #+end_src

* [keyword] alias

  #+begin_src jojo
  (def alias
    (keyword
      read/jo (> nick)
      (if (< nick) round-ket eq? then end)
      read/jo (> name)
      (if (< name) round-ket eq? then
          (string "- alias meet uneven list") string/print newline
          (string "  last nick : ") string/print (< nick) jo/print
          newline
          end)
      (el (lev ins/lit (< nick)
               ins/lit (< name)
               alias-push)
          (loop))))
  #+end_src

* [keyword] cat

*** cat

    #+begin_src jojo
    (def cat
      (keyword
        read/jo
        (if dup round-ket eq? then drop end)
        (if dup double-quote eq? then
            drop one-string
            (lev string/print)
            (loop))
        (if dup round-bar eq? then drop
            read/jo jo/apply (loop))
        (el here (loop))))
    #+end_src

*** test

    #+begin_src jojo
    (note (run (cat "1 2 3" newline "4 5 6" newline "7 8 9" newline)))
    #+end_src

* object note

  - class
    - one superclass
      thus single inheritance
    - meta-variable
    - meta-method
      two ways to implement object creation :
      [1] to use meta class -- class is an object
      [2] to use meta method -- class is not an object
      i will use [2]
    - instance-variable
      i.e. parts of the object
    - method-list
      where super can be used to use an method of superclass
      to implement a new method to override it

  - interface-generator
    when defining a class
    different interface-generator can be used to generate method list
    for example
    - low level array like data with free
    - high level list list data using gc

* [helper] class

  #+begin_src jojo
  (def class/get-tag                 (jojo (jo tag) assq car))

  (def class/has-superclass?         (jojo (jo inherit) assq null eq? not))
  (def class/get-super-tag           (jojo (jo inherit) assq car))

  (def class/has-meta-variable-list? (jojo (jo meta-variable) assq null eq? not))
  (def class/get-meta-variable-list  (jojo (jo meta-variable) assq car))

  (def class/has-meta-method-list?   (jojo (jo meta-method) assq null eq? not))
  (def class/get-meta-method-list    (jojo (jo meta-method) assq car))

  (def class/has-variable-list?      (jojo (jo variable) assq null eq? not))
  (def class/get-variable-list       (jojo (jo variable) assq car))

  (def class/has-method-list?        (jojo (jo method) assq null eq? not))
  (def class/get-method-list         (jojo (jo method) assq car))
  #+end_src

* [keyword] define-class

  #+begin_src jojo
  (def define-class/keyword/one-variable
    (keyword
      (lev ins/lit
           (esc read/jo here
                compile-jojo)
           cons cons cons)))

  (def define-class/keyword/one-bare-variable
    (keyword
      (lev ins/lit
           (esc read/jo here
                compile-jojo)
           ins/lit <data>
           cons cons cons)))

  (def jo-ending-with-colon?
    (jojo
      (note jo -> bool)
      jo->string string/last-char
      (string ":") string/last-char eq?))

  (def define-class/keyword/one-method/complex-message
    (keyword
      (note sum-jo -> sum-jo)
      read/jo
      (if dup round-ket eq? then drop end)
      (if dup jo-ending-with-colon? then
          jo/append
          (loop))
      swap (recur) swap
      (lev ins/lit
           (esc here)
           local-in)))

  (def define-class/keyword/one-method/message
    (keyword
      (note -> jo)
      read/jo
      (if dup round-bar eq? not then end)
      drop read/jo drop
      empty-jo define-class/keyword/one-method/complex-message))

  (def define-class/keyword/one-method/help
    (keyword
      (lev ins/jump)
      compiling-stack/tos (> offset-place)
      compiling-stack/inc
      compiling-stack/tos (> bare-jojo-place)
      define-class/keyword/one-method/message (> message)
      compile-jojo
      (lev end)
      compiling-stack/tos (< offset-place) set-cell
      (lev ins/lit (< bare-jojo-place)
           ins/lit (< message)
           swap
           cons)))

  (def define-class/keyword/one-method
    (keyword
      define-class/keyword/one-method/help
      (lev cons)))

  (def define-class/keyword/inherit
    (keyword
      (lev ins/lit inherit
           ins/lit
           (esc read/jo here
                ignore)
           cons
           cons)))

  (def define-class/keyword/meta-variable-list
    (keyword
      (alias = define-class/keyword/one-variable
             - define-class/keyword/one-bare-variable)
      (lev ins/lit meta-variable
           null
           (esc compile-jojo)
           cons
           cons)))

  (def define-class/keyword/meta-method-list
    (keyword
      (alias * define-class/keyword/one-method)
      (lev ins/lit meta-method
           null
           (esc compile-jojo)
           cons
           cons)))

  (def define-class/keyword/variable-list
    (keyword
      (alias = define-class/keyword/one-variable
             - define-class/keyword/one-bare-variable)
      (lev ins/lit variable
           null
           (esc compile-jojo)
           cons
           cons)))

  (def define-class/keyword/method-list
    (keyword
      (alias * define-class/keyword/one-method)
      (lev ins/lit method
           null
           (esc compile-jojo)
           cons
           cons)))

  (def define-class/help
    (keyword
      read/jo (> tag)
      (alias
        inherit       define-class/keyword/inherit
        meta-method   define-class/keyword/meta-method-list
        meta-variable define-class/keyword/meta-variable-list
        variable      define-class/keyword/variable-list
        method        define-class/keyword/method-list)
      (lev null
           ins/lit tag
           ins/lit (< tag)
           cons
           cons
           (esc compile-jojo)
           ins/lit <class>
           ins/lit (< tag))))

  (def define-class
    (keyword
      compiling-stack/tos (> begin)
      define-class/help
      (lev end)
      (< begin) apply
      bind-name))
  #+end_src

* send

*** send-to-class

    #+begin_src jojo
    (def send-to-class/find-meta-method
      (jojo
        (note class message -> [value <*> true] or [false])
        (> message)
        (> class)
        (if (< class) class/has-meta-method-list? then
            (< class) class/get-meta-method-list
            (< message)
            assoc/find
            (if then
                car
                true
                end))
        (if (< class) class/has-superclass? then
            (< class) class/get-super-tag jo/apply drop
            (< message)
            (loop))
        false))

    (def send-to-class
      (jojo
        (> message)
        (> tag)
        (> class)
        (< class) (< message)
        send-to-class/find-meta-method
        (if then
            current-local-pointer swap
            (< class) (< tag) (jo self) local-in
            apply-with-local-pointer
            end)
        (string "- send-to-class : can not find message : ") string/print
        (< message) jo/print newline))
    #+end_src

*** send-to-object

    #+begin_src jojo
    (def send-to-object/find-method
      (jojo
        (note tag message -> [bare-jojo true] or [false])
        (> message)
        (> tag)
        (< tag) jo/apply drop (> class)
        (if (< class) class/has-method-list? then
            (< class) class/get-method-list
            (< message) assoc/find
            (if then
                car
                true
                end))
        (if (< class) class/has-superclass? then
            (< class) class/get-super-tag
            (< message)
            (loop))
        false))

    (def send-to-object
      (jojo
        (> message)
        (> tag)
        (> data)
        (< tag) (< message)
        send-to-object/find-method
        (if then
            current-local-pointer swap
            (< data) (< tag) (jo self) local-in
            apply-with-local-pointer
            end)
        (string "- send-to-object : can not find message : ") string/print
        (< message) jo/print newline
        (string "  object/tag : ") string/print
        (< tag) jo/print newline))
    #+end_src

*** send

    #+begin_src jojo
    (def send
      (jojo
        (if over (jo <class>) eq? then send-to-class end)
        send-to-object))
    #+end_src

* [keyword] :

  #+begin_src jojo
  (def send/sugar/complex
    (keyword
      (note sum-jo -> sum-jo)
      read/jo
      (if dup round-ket eq? then drop end)
      (if dup round-bar eq? then drop read/jo jo/apply (loop))
      (if dup jo-ending-with-colon? then jo/append (loop))
      here (loop)))

  (def :
    (keyword
      (jo :) generate-jo (> object-jo)
      (lev ins/lit (< object-jo)
           local-in
           (esc read/jo
                (if dup jo-ending-with-colon? not
                    then (> message) compile-jojo
                    else send/sugar/complex (> message)))
           ins/lit (< object-jo)
           local-out
           ins/lit (< message)
           send)))
  #+end_src

* keywords for variable

*** variable-tracing meta-variable-tracing

    #+begin_src jojo
    (def variable->object (jojo car dup car swap cdr swap))

    (def variable-tracing
      (jojo
        (note tag name -> [data tag true] or [false])
        (> name)
        (> tag)
        (< tag) jo/apply drop (> class)
        (if (< class) class/has-variable-list? not then false end)
        (< class) class/get-variable-list
        (< name)
        assoc/find
        (if then variable->object true end)
        (if (< class) class/has-superclass? not then false end)
        (< class) class/get-super-tag
        (< name)
        (loop)))

    (def meta-variable-tracing
      (jojo
        (note class name -> [data tag true] or [false])
        (> name)
        (> class)
        (if (< class) class/has-meta-variable-list? then
            (< class) class/get-meta-variable-list
            (< name)
            assoc/find
            (if then variable->object true end)
            (if (< class) class/has-superclass? then
                (< class) class/get-super-tag
                jo/apply drop
                (< name)
                (loop)))
        (el false)))
    #+end_src

*** has?

    #+begin_src jojo
    (def has-instance-variable?
      (jojo
        (note [box tag name] -> true or false)
        (> name)
        (> tag)
        car (> variable-list)
        (< variable-list)
        (< name)
        assoc/find
        (if then drop true end)
        (< tag)
        (< name)
        variable-tracing
        (if then 2drop true end)
        (el false)))

    (def has-meta-variable?
      (jojo
        (note [class (jo <class>) name] -> true or false)
        swap drop
        meta-variable-tracing
        (if then 2drop true end)
        (el false)))

    (def has-variable?
      (jojo
        (note [data tag name] -> true or false)
        (if over (jo <class>) eq? not then
            has-instance-variable? end)
        (el has-meta-variable?)))

    (def has?
      (keyword
        (lev ins/lit
             (esc read/jo here
                  ignore)
             has-variable?)))
    #+end_src

*** get get-data get-tag

    #+begin_src jojo
    (def get-instance-variable
      (jojo
        (note [box tag name] -> [data tag])
        (> name)
        (> tag)
        car (> variable-list)
        (< variable-list)
        (< name)
        assoc/find
        (if then variable->object end)
        (< tag)
        (< name)
        variable-tracing
        (if then end)
        (el (cat "- get-instance-variable fail" newline
                 "  name : " name jo/print newline
                 "  tag : " (< tag) jo/print newline))))


    (def get-meta-variable
      (jojo
        (note [class (jo <class>) name] -> [data tag])
        swap drop
        meta-variable-tracing
        (if then end)
        (cat "- get-meta-variable fail" newline
             "  name : " name jo/print newline
             "  class-name : " (< class) class/get-tag jo/print newline)))

    (def get-variable
      (jojo
        (note [data tag name] -> [data tag])
        (if over (jo <class>) eq? not then
            get-instance-variable end)
        (el get-meta-variable)))


    (def get
      (keyword
        (lev ins/lit
             (esc read/jo here
                  ignore)
             get-variable)))

    (def get-data
      (keyword
        (lev ins/lit
             (esc read/jo here
                  ignore)
             get-variable drop)))

    (def get-tag
      (keyword
        (lev ins/lit
             (esc read/jo here
                  ignore)
             get-variable swap drop)))
    #+end_src

*** set

    - set will add a variable when can not find one along the inherit-link.

    #+begin_src jojo
    (def set-instance-variable
      (jojo
        (note [data tag box source-tag name] -> [])
        (> name)
        (> source-tag)
        dup (> box)
        car (> variable-list)
        (>> object)
        (< variable-list)
        (< name)
        assoc/find
        (if then (> variable)
            (<< object) cons
            (< variable) set-car
            end)
        (el (< name) (<< object) cons cons
            (< variable-list) swap cons
            (< box) set-car)))

    (def set-meta-variable
      (jojo
        (note [data tag class (jo <class>) name] -> [])
        (> name)
        drop
        (> class)
        (>> object)
        (if (< class) class/has-meta-variable-list? not then
            (jo meta-variable)
            null (< name) (<< object) cons cons
            cons
            cons
            (< class)
            set-tail
            end)
        (< class) class/get-meta-variable-list
        (> variable-list)
        (< variable-list)
        (< name)
        assoc/find
        (if then (> variable)
            (<< object) cons
            (< variable) set-car
            end)
        (el (< name) (<< object) cons cons
            (< variable-list)
            set-tail)))

    (def set-variable
      (jojo
        (note [data tag source-data source-tag name] -> [])
        (if over (jo <class>) eq? not then
            set-instance-variable end)
        (el set-meta-variable)))

    (def set
      (keyword
        (lev ins/lit
             (esc read/jo here
                  ignore)
             set-variable)))
    #+end_src

*** set-data

    #+begin_src jojo
    (def set-data-in-instance-variable
      (jojo
        (note [data box source-tag name] -> [])
        (> name)
        (> source-tag)
        (> box)
        (> data)

        (< box)
        (< source-tag)
        (< name)
        has-instance-variable?
        (if then
            (< box)
            (< source-tag)
            (< name)
            get-instance-variable
            swap drop
            else (jo <data>))

        (< data) swap
        (< box)
        (< source-tag)
        (< name)
        set-instance-variable))

    (def set-data-in-meta-variable
      (jojo
        (note [data class (jo <class>) name] -> [])
        (> name)
        (> tag)
        (> class)
        (> data)

        (< class)
        (< tag)
        (< name)
        has-meta-variable?
        (if then
            (< class)
            (< tag)
            (< name)
            get-meta-variable swap drop
            else (jo <data>))
        (< data) swap
        (< class)
        (< tag)
        (< name)
        set-meta-variable))

    (def set-data-in-variable
      (jojo
        (note [data source-data source-tag name] -> [])
        (if over (jo <class>) eq? not then
            set-data-in-instance-variable end)
        (el set-data-in-meta-variable)))

    (def set-data
      (keyword
        (lev ins/lit
             (esc read/jo here
                  ignore)
             set-data-in-variable)))
    #+end_src

* [keyword] add-method

  #+begin_src jojo
  (def add-method
    (keyword
      read/jo (> tag)
      (< tag) jo/apply drop (> class)
      compiling-stack/tos (> begin)
      define-class/keyword/one-method/help
      (lev end)
      (< begin) apply (> method)

      (if (< class) class/has-method-list? not then
          (jo method) (< method) cons
          (< class) set-tail end)
      (el (< method)
          (< class) class/get-method-list
          set-tail)))
  #+end_src

* <int>

*** <int>

    #+begin_src jojo
    (define-class <int>
      (method
        (* inc (< self) inc (<% self))
        (* dec (< self) dec (<% self))
        (* neg (< self) neg (<% self))

        (* (: add: i) (< self) (< i) add (<% self))
        (* (: sub: i) (< self) (< i) sub (<% self))
        (* (: mul: i) (< self) (< i) mul (<% self))
        (* (: div: i) (< self) (< i) div (<% self))
        (* (: mod: i) (< self) (< i) mod (<% self))

        (* (: eq?: i) (< self) (< i) eq?)
        (* (: gt?: i) (< self) (< i) gt?)
        (* (: lt?: i) (< self) (< i) lt?)
        (* (: gteq?: i) (< self) (< i) gteq?)
        (* (: lteq?: i) (< self) (< i) lteq?)

        (* print (< self) integer/print)
        (* dot (< self) integer/dot)
        (* write (string "(int ") string/print
           (<< self) (: print)
           (string ") ") string/print)))
    #+end_src

*** [keyword] int

    #+begin_src jojo
    (def int
      (keyword
        (jo integer) jo/apply
        (lev ins/lit <int>)))
    #+end_src

* <str>

*** note

    - <str> is static allocated,
      no gc for this class.

*** <str>

    #+begin_src jojo
    (define-class <str>
      (method
        (* print (< self) string/print)
        (* length (< self) string/length (jo <int>))
        (* write
           (string "(str ") string/print
           double-quote jo/print
           (<< self) (: print)
           double-quote jo/print
           (string ") ") string/print)))
    #+end_src

*** [keyword] str

    #+begin_src jojo
    (def str
      (keyword
        (jo string) jo/apply
        (lev ins/lit <str>)))
    #+end_src

*** test

    #+begin_src jojo
    (note
      (test (str "k1 k2 k3")
            2dup (: print) newline
            2dup (: write) newline
            2dup (: length) (: print) newline
            2dup (: length) (: write) newline
            2drop))
    #+end_src

* <object>

*** note

    - initially the data of an <object> is an empty-box.
      and it will be a box of variable-list,
      i.e. an assoc-list of name and object.
      the assoc-list is generated lazily by the keyword 'set'.

*** <object>

    #+begin_src jojo
    (define-class <object>
      (meta-variable
        (= testing-meta-variable-in-<object> (int 26881)))
      (meta-method
        (* new
           null null cons
           (< self) class/get-tag)))
    #+end_src

* <jojo>

*** note

    - play with combinators

*** <jojo>

    #+begin_src jojo
    (define-class <jojo>
      (method
        (* apply (< self) apply)))
    #+end_src

* <table>

*** <table>

    #+begin_src jojo
    (define-class <table>
      (method
        (* find )))
    #+end_src

* <stack>

*** <bare-stack>

    #+begin_src jojo
    (define-class <bare-stack>
      (inherit <object>)
      (variable
        (- stack null))
      (method
        (* pop
           (<< self) (get-data stack)
           dup car (> data)
           cdr (<< self) (set-data stack)
           (< data))
        (* (: push: data)
           (<< self) (get-data stack)
           (< data)
           cons
           (<< self) (set-data stack))))
    #+end_src

*** >< <stack>

    #+begin_src jojo
    (note (define-class <stack>
            (inherit <bare-stack>)
            (method
              (* pop
                 )
              (* (: push: value)
                 ))))
    #+end_src

* >< <system>

*** system

    #+begin_src jojo
    (test current-dir string/print newline)

    (test (string "HOME") var-string->env-string
          string/print newline)

    (test (string "PATH") var-string->env-string
          string/print newline)

    (def command-line/print-argument/loop
      (jojo (note index -> [io])
        (if dup argument-counter lt? then
            dup index->argument-string string/print
            newline
            (integer 1) add
            (loop))
        drop end))

    (def command-line/print-argument
      (jojo (note -> [io])
        (integer 0) command-line/print-argument/loop))

    (test command-line/print-argument)

    (note (test def-report))
    #+end_src

* <path>

*** <path>

    #+begin_src jojo
    (define-class <path>
      (inherit <str>)
      (method
        (* write
           (string "(path ") string/print
           double-quote jo/print
           (<< self) (: print)
           double-quote jo/print
           (string ") ") string/print)))

    (add-method <str> to-path
      (< self) (jo <path>))
    #+end_src

*** test

    #+begin_src jojo
    (test (str "/home/") (: to-path) (: write))
    #+end_src

* >< <file>

*** note

    #+begin_src jojo
    (note

      (define-class <file>
        (method
          (* close)))

      (add-method <path> open-for-reading
        (< self) string/open-for-reading)

      (add-method <path> (: open-for: flags)
        (note fd = open(pathname, flags, mode)
              if the file doesnâ€™t exist,
              open() may create it,
              depending on the settings of the flags bitmask argument.
              the flags argument also specifies
              whether the file is to be opened for reading, writing, or both.))

      (add-method <path> (: open-for: flags with: mode)
        (note the mode argument specifies the permissions
              to be placed on the file if it is created by this call.
              If the open() call is not being used to create a file,
              this argument is ignored and can be omitted))

      (note numread = read(fd, buffer, count)
            reads at most count bytes from the open file
            referred to by fd and stores them in buffer.
            The read() call returns the number of bytes actually read.
            If no further bytes could be read
            (i.e., end-of-file was encountered),
            read() returns 0.)

      (note numwritten = write(fd, buffer, count)
            writes up to count bytes from buffer to the open file
            referred to by fd.
            The write() call returns the number of bytes actually written,
            which may be less than count.)

      (note status = close(fd)
            is called after all I/O has been completed,
            in order to release the file descriptor fd
            and its associated kernel resources.))
    #+end_src

*** test

    #+begin_src jojo
    (test (string "README") file/size dot)

    (test (string "README") file/readable? dot)

    (test (string "README")
          dup file/size
          allocate tuck file/copy-to-buffer
          drop
          string/print
          newline)
    #+end_src

* >< <module>

*** note

    - module is simply a dir of source code files,
      with a module.jo to store meta data of the module.

    - a module-record for loaded modules to avoid reload.

    - install modules to "~/.jojo/module/"
      as "module-name/version/*"

    - command-line interface of module-system :
      install
      uninstall
      reinstall

    - module-system helps name to be unique
      by adding prefix to name
      prefix is simply "module-name[version]."

    - a package manager to download dependences and install them.

    - unique naming is ensured by prefix,
      thus no export-list,
      thus all of a module are exposed to a user of the module.

    #+begin_src jojo
    (note
      (module module-name [version])
      (use module-name [version]
           ...)
      (include "path"))

    (note
      (load-module module-name[version])

      module-stack module-name[version]

      define name
      def module-name[version].name

      defining-stack name module-name[version].name)
    #+end_src

*** note module

    - x -
      module-stack for current defining-prefix
      defining-stack for current names to be prefixed

      - thus in a module
        one can not use name in core

        when one wants to use a name in core in his module
        he must prefix his version of this name by '.'

        thus the core must be very small
        and it must be fixed in early version of the language

*** module-stack

    #+begin_src jojo
    (note
      (def module-stack
        ))
    #+end_src

*** module-record

    #+begin_src jojo
    (note
      (def module-record
        ))
    #+end_src

* >< <clib>

*** note

    - [ffi]
      c is only used to implement primitive object ?
      and to do optimization ?

*** example

    #+begin_src jojo
    (note
      (include "path")
      (clib "path"))
    #+end_src

* test

  #+begin_src jojo
  (define-class <person>
    (inherit <object>)
    (meta-variable
      (= testing-meta-variable (int 666)))
    (variable
      (- bare-age (integer 5))
      (= age (int 13))
      (= language (str "chinese")))
    (method
      (* grow
         (<< self) (get age) (: inc)
         (<< self) (cat "<here> ") (set age) (cat "<here> "))
      (* (: grow-by: years)
         (<< self) (get age) (: add: (<< years))
         (<< self) (set age))
      (* (: grow-by: year1 and-by: year2)
         (<< self) (get age) (: add: (<< year1)) (: add: (<< year2))
         (<< self) (set age))
      (* report
         (cat "bare-age : "
              (<< self) (get-data bare-age) integer/print newline
              "age : "
              (<< self) (get age) (: print) newline
              "languege : "
              (<< self) (get language) (: print) newline
              newline))))

  (def xieyuheng <person> (: new))

  (run xieyuheng (: report)
       xieyuheng (: grow)
       xieyuheng (: report)
       xieyuheng (: grow-by: (int 10))
       xieyuheng (: report)
       xieyuheng (: grow-by: (int 10))
       xieyuheng (: report)
       xieyuheng (: grow-by: (int 10) and-by: (int 10))
       xieyuheng (: report))

  (run <person> (get testing-meta-variable) (: write)
       (int 777)
       <person> (set testing-meta-variable)
       <person> (get testing-meta-variable) (: write)
       (int 888)
       <person> (set testing-meta-variable)
       <person> (get testing-meta-variable) (: write)
       <person> (get testing-meta-variable-in-<object>) (: write)

       (int 26078)
       <person> (set testing-meta-variable-0)
       <person> (get testing-meta-variable-0) (: write))
  #+end_src

* test

  #+begin_src jojo
  (note (test (string "asd") open-for-reading dot)
        (test (string "README") open-for-reading dot))
  #+end_src

* test

  #+begin_src jojo
  (def module-stack <bare-stack> (: new))

  (test module-stack (: push: (data (integer 1)))
        module-stack (: push: (data (integer 2)))
        module-stack (: push: (data (integer 3)))
        module-stack (: pop) integer/print newline
        module-stack (: pop) integer/print newline
        module-stack (: pop) integer/print newline)
  #+end_src
