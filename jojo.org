#+HTML_HEAD: <link rel="stylesheet" href="http://xieyuheng.github.io/asset/css/page.css" type="text/css" media="screen" />
#+PROPERTY: tangle jojo.c
#+TITLE:  jojo

---------

- the implementation of the interpreter ([[https://github.com/xieyuheng/jojo][source]])

---------

* todo

  - to regulate the use of "-" and "/" in naming
  - how to handle jo and lambda ?
  - fix semantic of case no "in between"
  - [safe] error report for every limited number
  - [safe] to handle all the error
  - [debug] print jojo body
  - [debug] print return-stack
  - [debug] debug repl
  - [debug] trace
  - [debug] step
  - [test] test framework
  - [test] test module system
  - doc
  - install
  - package manager
  - better jotable for being compiler target
  - better structure of code
  - factor some functions out to module

* helper

*** header

    #+begin_src c
    #include <stdio.h>
    #include <ctype.h>
    #include <stdlib.h>
    #include <stdint.h>
    #include <setjmp.h>
    #include <string.h>
    #include <dlfcn.h>
    #include <unistd.h>
    #include <sys/types.h>
    #include <dirent.h>
    #+end_src

*** bool

    #+begin_src c
    typedef enum { false, true } bool;
    #+end_src

*** cell

    #+begin_src c
    typedef intptr_t cell;
    #+end_src

*** int

    #+begin_src c
    cell max(cell a, cell b) {
      if (a < b) {
        return b;
      }
      else {
        return a;
      }
    }

    cell min(cell a, cell b) {
      if (a > b) {
        return b;
      }
      else {
        return a;
      }
    }

    cell power(cell a, cell n) {
      cell result = 1;
      while (n >= 1) {
        result = result * a;
        n--;
      }
      return result;
    }
    #+end_src

*** char

    #+begin_src c
    bool isbarcket(char c) {
      return (c == '(' ||
              c == ')' ||
              c == '[' ||
              c == ']' ||
              c == '{' ||
              c == '}' ||
              c == '"');
    }
    #+end_src

*** char_to_nat

    #+begin_src c
    cell char_to_nat(char c) {
      if (c >= '0' && c <= '9') {
        return (c - '0');
      }
      else if (c >= 'A' && c <= 'Z') {
        return (c - 'A') + 10;
      }
      else if (c >= 'a' && c <= 'z') {
        return (c - 'a') + 10;
      }
      else {
        return 0;
      }
    }
    #+end_src

*** string

***** string

      #+begin_src c
      typedef char* string;
      #+end_src

***** string_equal

      #+begin_src c
      bool string_equal(string s1, string s2) {
        if (strcmp(s1, s2) == 0) {
          return true;
        }
        else {
          return false;
        }
      }
      #+end_src

***** nat_string_p

      #+begin_src c
      bool nat_string_p(string str) {
        cell i = 0;
        while (str[i] != 0) {
          if (!isdigit(str[i])) {
            return false;
            }
          i++;
        }
        return true;
      }
      #+end_src

***** int_string_p

      #+begin_src c
      bool int_string_p(string str) {
        if (str[0] == '-' ||
            str[0] == '+') {
          return nat_string_p(str + 1);
        }
        else {
          return nat_string_p(str);
        }
      }
      #+end_src

***** string_to_based_[nat|int]

      #+begin_src c
      cell string_to_based_nat(string str, cell base) {
        cell result = 0;
        cell len = strlen(str);
        cell i = 0;
        while (i < len) {
          result = result + (char_to_nat(str[i]) * power(base, (len - i - 1)));
          i++;
        }
        return result;
      }

      cell string_to_based_int(string str, cell base) {
        if (str[0] == '-') {
          return - string_to_based_nat(str, base);
        }
        else {
          return string_to_based_nat(str, base);
        }
      }
      #+end_src

***** string_to_[dec|bin|oct|hex]

      #+begin_src c
      cell string_to_dec(string str) { return string_to_based_int(str, 10); }
      cell string_to_bin(string str) { return string_to_based_int(str,  2); }
      cell string_to_oct(string str) { return string_to_based_int(str,  8); }
      cell string_to_hex(string str) { return string_to_based_int(str, 16); }
      #+end_src

* jotable

*** primitive

    #+begin_src c
    typedef void (*primitive)();
    #+end_src

*** jo & jojo

    #+begin_src c
    typedef cell jo;

    typedef struct {
      cell size;
      jo *array;
    } jojo;
    #+end_src

*** bind & jotable_entry

    #+begin_src c
    typedef union {
      cell cell;
      primitive primitive;
      jojo jojo;
    } bind;

    typedef struct {
      cell index;
      string key;
      jo type;
      bind value;
      cell orbit_length;
      cell orbiton;
    } jotable_entry;
    #+end_src

*** proto_jotable_entry

    #+begin_src c
    jo str2jo (string str);

    jotable_entry proto_jotable_entry(cell index) {
      jotable_entry e = {
        .index = index,
        .key = 0,
        .type = str2jo("none"),
        .value.cell = 0,
        .orbit_length = 0,
        .orbiton = 0
      };
      return e;
    }
    #+end_src

*** jotable_entry_[occured|entry_used|no_collision]

    #+begin_src c
    bool jotable_entry_occured(jotable_entry e) {
      return e.key != 0;
    }

    bool jotable_entry_used(jotable_entry e) {
      return e.type != str2jo("none");
    }

    bool jotable_entry_no_collision(jotable_entry e) {
      return e.index == e.orbiton;
    }
    #+end_src

*** jotable

    #+begin_src c
    // prime table size
    //   1000003   about 976 k
    //   1000033
    //   1000333
    //   100003    about 97 k
    //   100333
    //   997
    #define jotable_size 100003
    jotable_entry jotable[jotable_size];
    cell jotable_counter = 0;
    #+end_src

*** string_to_sum

    #+begin_src c
    cell string_to_sum(string str) {
      cell sum = 0;
      cell max_step = 10;
      cell i = 0;
      while (i < strlen(str)) {
        sum = sum + ((unsigned char) str[i]) * (2 << min(i, max_step));
        i++;
      }
      return sum;
    }
    #+end_src

*** jotable_keyeq

    #+begin_src c
    bool jotable_keyeq(string k1, string k2) {
      return string_equal(k1, k2);
    }
    #+end_src

*** jotable_hash

    #+begin_src c
    cell jotable_hash(string key, cell counter) {
      return (counter + string_to_sum(key)) % jotable_size;
    }
    #+end_src

*** string_area

    #+begin_src c
    char string_area[4 * 1024 * 1024];
    cell string_area_counter = 0;
    #+end_src

*** copy_to_string_area

    #+begin_src c
    string copy_to_string_area(string str) {
      char *str1;
      cell i = 0;
      str1 = (string_area + string_area_counter);
      while (true) {
        if (str[i] == 0) {
          str1[i] = str[i];
          i++;
          break;
        }
        else {
          str1[i] = str[i];
          i++;
        }
      }
      string_area_counter = i + string_area_counter;
      return str1;
    }
    #+end_src

*** jotable_insert

    #+begin_src c
    // -1 denotes the hash_table is filled
    cell jotable_insert(string key) {
      cell orbit_index = jotable_hash(key, 0);
      cell counter = 0;
      while (true) {
        cell index = jotable_hash(key, counter);
        if (!jotable_entry_occured(jotable[index])) {
          key = copy_to_string_area(key);
          jotable[index].key = key;
          jotable[index].orbiton = orbit_index;
          jotable[orbit_index].orbit_length = 1 + counter;
          jotable_counter = 1 + jotable_counter;
          return index;
        }
        else if (jotable_keyeq(key, jotable[index].key)) {
          return index;
        }
        else if (counter == jotable_size) {
          return -1;
        }
        else {
          counter = 1 + counter;
        }
      }
    }
    #+end_src

*** jotable_search

    #+begin_src c
    // -1 denotes key not occured
    cell jotable_search(string key) {
      cell counter = 0;
      while (true) {
        cell index = jotable_hash(key, counter);
        if (!jotable_entry_occured(jotable[index])) {
          return -1;
        }
        else if (jotable_keyeq(key, jotable[index].key)) {
          return index;
        }
        else if (counter == jotable_size) {
          return -1;
        }
        else {
          counter = 1 + counter;
        }
      }
    }
    #+end_src

*** jotable_entry_print

    #+begin_src c
    string jo2str (cell index);

    void jotable_entry_print(jotable_entry entry) {
      printf("%s : ", jo2str(entry.type));
      if (entry.type == str2jo("variable")) {
        printf("%ld", entry.value.cell);
      }
      else if (entry.type == str2jo("primitive")) {
        printf("%ld", entry.value.primitive);
      }
      else if (entry.type == str2jo("function")) {
        printf("%ld ", entry.value.jojo.size);
        printf("[ ");
        cell i;
        for (i=0; i < entry.value.jojo.size; i=i+1) {
          printf("%ld ", entry.value.jojo.array[i]);
        }
        printf("]");
      }
    }
    #+end_src

*** jotable_report_orbit

    #+begin_src c
    void jotable_report_orbit(cell index, cell counter) {
      while (counter < jotable[index].orbit_length) {
        string key = jotable[index].key;
        cell next_index = jotable_hash(key, counter);
        if (index == jotable[next_index].orbiton) {
          printf("  | %ld %s\n", next_index, jotable[next_index].key);
        }
        if (jotable_entry_used(jotable[next_index])) {
          printf("    = ");
          jotable_entry_print(jotable[next_index]);
          printf("\n");
        }
        counter = 1 + counter;
      }
    }
    #+end_src

*** jotable_report

    #+begin_src c
    void jotable_report() {
      printf("\n");
      printf("- jotable_report\n");
      printf("  : <index> <key> // <orbit-length>\n");
      cell index = 0;
      while (index < jotable_size) {
        if (jotable_entry_occured(jotable[index]) &&
            jotable_entry_no_collision(jotable[index])) {
          printf("  - %ld %s // %ld\n",
                 index, jotable[index].key, jotable[index].orbit_length);
          if (jotable_entry_used(jotable[index])) {
            printf("    = ");
            jotable_entry_print(jotable[index]);
            printf("\n");
          }
          jotable_report_orbit(index, 1);
        }
        index = 1 + index;
      }
      printf("  : <index> <key> // <orbit-length>\n");
      printf("\n");
      printf("- used : %ld\n", jotable_counter);
      printf("- free : %ld\n", jotable_size - jotable_counter);
    }
    #+end_src

*** jotable_print

    #+begin_src c
    void jotable_print() {
      printf("\n");
      printf("- jotable_print\n");
      cell index = 0;
      while (index < jotable_size) {
        printf("  - %ld %s %ld // %ld\n",
               index,
               jotable[index].key,
               jotable[index].value,
               jotable[index].orbit_length);
        index = 1 + index;
      }
      printf("\n");
      printf("- used : %ld\n", jotable_counter);
      printf("- free : %ld\n", jotable_size - jotable_counter);
    }
    #+end_src

*** str2jo & jo2str

    #+begin_src c
    jo str2jo(string str) {
      return jotable_insert(str);
    }

    string jo2str(cell index) {
      return jotable[index].key;
    }
    #+end_src

*** init_jotable

    #+begin_src c
    void init_jotable() {
      cell i = 0;
      while (i < jotable_size) {
        jotable[i] = proto_jotable_entry(i);
        i++;
      }
    }
    #+end_src

*** jojo_area

    #+begin_src c
    jo jojo_area[1024 * 1024];
    #+end_src

*** here

***** compiling_stack

      #+begin_src c
      typedef jo* compiling_stack_t[1024];

      compiling_stack_t compiling_stack;
      cell compiling_stack_base = 0;
      cell compiling_stack_pointer = 0;

      void compiling_stack_push(jo* value) {
        compiling_stack[compiling_stack_pointer] = value;
        compiling_stack_pointer++;
      }

      jo* compiling_stack_pop() {
        compiling_stack_pointer--;
        return compiling_stack[compiling_stack_pointer];
      }

      void compiling_stack_inc() {
        compiling_stack[compiling_stack_pointer - 1] =
          compiling_stack[compiling_stack_pointer - 1] + 1;
      }


      jo* compiling_stack_tos() {
        return compiling_stack[compiling_stack_pointer - 1];
      }

      bool compiling_stack_empty_p() {
        return compiling_stack_pointer == compiling_stack_base;
      }
      #+end_src

***** init_compiling_stack

      #+begin_src c
      void init_compiling_stack() {
        compiling_stack_push(jojo_area);
      }
      #+end_src

***** here

      #+begin_src c
      void here(cell n) {
        jo* pointer = compiling_stack_pop();
        pointer[0] = n;
        compiling_stack_push(pointer + 1);
      }
      #+end_src

*** jotable_set_cell

    #+begin_src c
    void jotable_set_cell(cell index, cell cell) {
      jotable[index].type = str2jo("variable");
      jotable[index].value.cell = cell;
    }
    #+end_src

*** jotable_set_primitive

    #+begin_src c
    void jotable_set_primitive(cell index, primitive primitive) {
      jotable[index].type = str2jo("primitive");
      jotable[index].value.primitive = primitive;
    }
    #+end_src

*** jotable_get_cell

    #+begin_src c
    cell jotable_get_cell(cell index) {
      return jotable[index].value.cell;
    }
    #+end_src

*** jotable_get_primitive

    #+begin_src c
    primitive jotable_get_primitive(cell index) {
      return jotable[index].value.primitive;
    }
    #+end_src

*** jotable_get_jojo

    #+begin_src c
    jojo jotable_get_jojo(cell index) {
      return jotable[index].value.jojo;
    }
    #+end_src

*** test

    #+begin_src c
    void jotable_test() {
      str2jo("testkey0");
      str2jo("testkey1");
      str2jo("testkey2");
      str2jo("testkey3");
      str2jo("testkey4");

      str2jo("testkey0");
      str2jo("testkey1");
      str2jo("testkey2");
      str2jo("testkey3");
      str2jo("testkey4");

      str2jo("testtestkey0");
      str2jo("testtestkey1");
      str2jo("testtestkey2");
      str2jo("testtestkey3");
      str2jo("testtestkey4");

      str2jo("testtesttestkey0");
      str2jo("testtesttestkey1");
      str2jo("testtesttestkey2");
      str2jo("testtesttestkey3");
      str2jo("testtesttestkey4");

      str2jo("testtesttesttestkey0");
      str2jo("testtesttesttestkey1");
      str2jo("testtesttesttestkey2");
      str2jo("testtesttesttestkey3");
      str2jo("testtesttesttestkey4");

      jotable_set_cell(str2jo("k1"), 1);
      jotable_report();

      jotable_set_cell(str2jo("k1"), 0);
      jotable_report();

      // jotable_print();
    }
    #+end_src

* defprim

*** defprim_record

    #+begin_src c
    jo defprim_record[64 * 1024];
    cell defprim_record_counter = 0;
    #+end_src

*** defprim_report

    #+begin_src c
    void defprim_report() {
      printf("- defprim_report // counter : %ld\n", defprim_record_counter);
      cell i = 0;
      while (i < defprim_record_counter) {
        printf("  %s\n", jo2str(defprim_record[i]));
        i++;
      }
      printf("\n");
    }
    #+end_src

*** defprim

    #+begin_src c
    void k_ignore();
    bool used_jo_p(jo index);
    jo jo_to_jo_in_module(jo alias_jo);

    void defprim(string str, primitive fun) {
      jo index = jo_to_jo_in_module(str2jo(str));
      if (used_jo_p(index)) {
        printf("- defprim can not re-define : %s\n", jo2str(index));
        printf("  it already defined as : %s\n", jo2str(jotable[index].type));
        k_ignore();
        return;
      }
      defprim_record[defprim_record_counter] = index;
      defprim_record_counter++;
      defprim_record[defprim_record_counter] = 0;
      jotable_set_primitive(index, fun);
    }
    #+end_src

* as & rs

*** as

    #+begin_src c
    typedef cell argument_stack[1024 * 4];

    argument_stack as;
    cell as_base = 64;
    cell as_pointer = 64;

    void as_push(cell value) {
      as[as_pointer] = value;
      as_pointer++;
    }

    cell as_pop() {
      as_pointer--;
      return as[as_pointer];
    }
    #+end_src

*** rs

    #+begin_src c
    typedef jo* return_stack[1024 * 4];

    return_stack rs;
    cell rs_base = 64;
    cell rs_pointer = 64;

    void rs_push(jo* value) {
      rs[rs_pointer] = value;
      rs_pointer++;
    }

    jo* rs_pop() {
      rs_pointer--;
      return rs[rs_pointer];
    }
    #+end_src

* jo_apply & apply

*** note

    - be careful when calling apply function in primitive
      because after rs_push a jojo
      one need to exit current primitive to run the jojo

*** jo_apply

    #+begin_src c
    void jo_apply(jo jo) {
      if (!jotable_entry_used(jotable[jo])) {
        printf("undefined jo : %s\n", jo2str(jo));
        return;
      }
      cell jo_type = jotable[jo].type;
      if (jo_type == str2jo("primitive")) {
        primitive primitive = jotable_get_primitive(jo);
        primitive();
      }
      else if (jo_type == str2jo("function")) {
        jojo jojo = jotable_get_jojo(jo);
        rs_push(jojo.array);
      }
      else if (jo_type == str2jo("variable")) {
        cell cell = jotable_get_cell(jo);
        as_push(cell);
      }
    }
    #+end_src

*** p_jo_apply

    #+begin_src c
    void p_jo_apply() {
      jo_apply(as_pop());
    }
    #+end_src

*** apply

    #+begin_src c
    void apply(jo* jojo_array) {
      rs_push(jojo_array);
    }
    #+end_src

*** p_apply

    #+begin_src c
    void p_apply() {
      apply(as_pop());
    }
    #+end_src

* eval

*** eval

    #+begin_src c
    jmp_buf eval_jmp_buffer;

    bool exit_eval() {
      longjmp(eval_jmp_buffer, 666);
    }

    void eval() {
      if (666 == setjmp(eval_jmp_buffer)) {
        return;
      }
      else {
        cell rs_base = rs_pointer;
        while (rs_pointer >= rs_base) {
          jo* function_body = rs_pop();
          rs_push(function_body + 1);
          cell jo = *(cell*)function_body;
          jo_apply(jo);
        }
      }
    }
    #+end_src

*** eval_jo

    #+begin_src c
    void eval_jo(jo jo) {
      cell jo_type = jotable[jo].type;
      if (jo_type == str2jo("primitive")) {
        primitive primitive = jotable_get_primitive(jo);
        primitive();
      }
      else if (jo_type == str2jo("function")) {
        jojo jojo = jotable_get_jojo(jo);
        rs_push(jojo.array);
        eval();
      }
      else if (jo_type == str2jo("variable")) {
        cell cell = jotable_get_cell(jo);
        as_push(cell);
      }
    }
    #+end_src

*** eval_key

    #+begin_src c
    void k_ignore();

    void eval_key(jo jo) {
      if (!jotable_entry_used(jotable[jo])) {
        printf("undefined keyword : %s\n", jo2str(jo));
        k_ignore();
        return;
      }
      eval_jo(jo);
    }
    #+end_src

*** eval_jojo

    #+begin_src c
    void eval_jojo(jo* array) {
      rs_push(array);
      eval();
    }
    #+end_src

* *stack_operation*

*** cell_copy

    #+begin_src c
    void cell_copy(cell length, cell* from, cell* to) {
      cell i = 0;
      while (i < length) {
        to[i] = from[i];
        i++;
      }
    }
    #+end_src

*** p_drop

    #+begin_src c
    void p_drop() {
      // (a ->)
      as_pop();
    }
    #+end_src

*** p_dup

    #+begin_src c
    void p_dup() {
      // (a a -> a)
      cell a = as_pop();
      as_push(a);
      as_push(a);
    }
    #+end_src

*** p_over

    #+begin_src c
    void p_over() {
      // (a b -> a b a)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a);
      as_push(b);
      as_push(a);
    }
    #+end_src

*** p_tuck

    #+begin_src c
    void p_tuck() {
      // (a b -> b a b)
      cell b = as_pop();
      cell a = as_pop();
      as_push(b);
      as_push(a);
      as_push(b);
    }
    #+end_src

*** p_swap

    #+begin_src c
    void p_swap() {
      // (a b -> b a)
      cell b = as_pop();
      cell a = as_pop();
      as_push(b);
      as_push(a);
    }
    #+end_src

*** p_xy_swap

    #+begin_src c
    void p_xy_swap() {
      // (xxx yyy x y -> yyy xxx)
      cell y = as_pop();
      cell x = as_pop();
      cell* yp = calloc(y, sizeof(cell));
      cell* xp = calloc(x, sizeof(cell));
      cell_copy(y, (as + (as_pointer - y)), yp);
      cell_copy(x, (as + (as_pointer - y - x)), xp);
      cell_copy(y, yp, (as + (as_pointer - y - x)));
      cell_copy(x, xp, (as + (as_pointer - x)));
      free(yp);
      free(xp);
    }
    #+end_src

*** p_print_stack

    #+begin_src c
    void p_print_stack() {
      // ([io] ->)
      printf("\n");
      if (as_pointer < as_base) {
        printf("  * %ld *  ", (as_pointer - as_base));
        printf("-- below the stack --\n");
      }
      else {
        printf("  * %ld *  ", (as_pointer - as_base));
        printf("-- ");
        cell i = as_base;
        while (i < as_pointer) {
          printf("%ld ", as[i]);
          i++;
        }
        printf("--\n");
      }
    }
    #+end_src

*** p_stack_base

    #+begin_src c
    void p_stack_base() {
      as_push(as + as_base);
    }
    #+end_src

*** p_stack_pointer

    #+begin_src c
    void p_stack_pointer() {
      as_push(as + as_pointer);
    }
    #+end_src

*** export_stack_operation

    #+begin_src c
    void export_stack_operation() {
      defprim("drop", p_drop);
      defprim("dup", p_dup);
      defprim("over", p_over);
      defprim("tuck", p_tuck);
      defprim("swap", p_swap);
      defprim("xy-swap", p_xy_swap);
      defprim("print-stack", p_print_stack);
      defprim("stack-pointer", p_stack_pointer);
      defprim("stack-base", p_stack_base);
    }
    #+end_src

* *ending*

*** p_end

    #+begin_src c
    void p_end() {
      // (rs: addr ->)
      rs_pop();
    }
    #+end_src

*** p_bye

    #+begin_src c
    void p_bye() {
      // (-> [exit])
      printf("bye bye ^-^/\n");
      exit(0);
    }
    #+end_src

*** export_ending

    #+begin_src c
    void export_ending() {
      defprim("end", p_end);
      defprim("bye", p_bye);
    }
    #+end_src

* *control*

*** i_lit

    #+begin_src c
    void i_lit() {
      // ([rs] -> int)
      jo* function_body = rs_pop();
      rs_push(function_body + 1);
      cell jo = *(cell*)function_body;
      as_push(jo);
    }
    #+end_src

*** i_tail_call

    #+begin_src c
    void i_tail_call() {
      // ([rs] -> int)
      jo* function_body = rs_pop();
      cell jo = *(cell*)function_body;
      jo_apply(jo);
    }
    #+end_src

*** p_jump_if_false

    #+begin_src c
    void p_jump_if_false() {
      // (bool addr -> [rs])
      jo* a = as_pop();
      cell b = as_pop();
      if (b == 0) {
        rs_pop();
        rs_push(a);
      }
    }
    #+end_src

*** export_control

    #+begin_src c
    void export_control() {
      defprim("i-lit", i_lit);
      defprim("i-tail-call", i_tail_call);
      defprim("jump-if-false", p_jump_if_false);
    }
    #+end_src

* *bool*

*** p_true

    #+begin_src c
    void p_true() {
      as_push(1);
    }
    #+end_src

*** p_false

    #+begin_src c
    void p_false() {
      as_push(0);
    }
    #+end_src

*** p_not

    #+begin_src c
    void p_not() {
      // (bool -> bool)
      cell a = as_pop();
      as_push(!a);
    }
    #+end_src

*** p_and

    #+begin_src c
    void p_and() {
      // (bool bool -> bool)
      cell a = as_pop();
      cell b = as_pop();
      as_push(a&&b);
    }
    #+end_src

*** p_or

    #+begin_src c
    void p_or() {
      // (bool bool -> bool)
      cell a = as_pop();
      cell b = as_pop();
      as_push(a||b);
    }
    #+end_src

*** export_bool

    #+begin_src c
    void export_bool() {
      defprim("true", p_true);
      defprim("false", p_false);
      defprim("not", p_not);
      defprim("and", p_and);
      defprim("or", p_or);
    }
    #+end_src

* *bit*

*** p_bit_true

    #+begin_src c
    void p_bit_true() {
      // (-> cell)
      cell i = -1;
      as_push(i);
    }
    #+end_src

*** p_bit_false

    #+begin_src c
    void p_bit_false() {
      // (-> cell)
      as_push(0);
    }
    #+end_src

*** p_bit_and

    #+begin_src c
    void p_bit_and() {
      // (cell cell -> cell)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a&b);
    }
    #+end_src

*** p_bit_or

    #+begin_src c
    void p_bit_or() {
      // (cell cell -> cell)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a|b);
    }
    #+end_src

*** p_bit_xor

    #+begin_src c
    void p_bit_xor() {
      // (cell cell -> cell)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a^b);
    }
    #+end_src

*** p_bit_not

    #+begin_src c
    void p_bit_not() {
      // (cell -> cell)
      cell a = as_pop();
      as_push(~a);
    }
    #+end_src

*** p_bit_shift_left

    #+begin_src c
    void p_bit_shift_left() {
      // (cell step -> cell)
      cell s = as_pop();
      cell a = as_pop();
      as_push(a<<s);
    }
    #+end_src

*** note shift_right & arithmetic_shift_right

    - must not use >> because its meaning is not sure in c

*** export_bit

    #+begin_src c
    void export_bit() {
      defprim("bit/true", p_bit_true);
      defprim("bit/false", p_bit_false);
      defprim("bit/not", p_bit_not);
      defprim("bit/and", p_bit_and);
      defprim("bit/xor", p_bit_xor);
      defprim("bit/or", p_bit_or);
      defprim("bit/shift-left", p_bit_shift_left);
      // defprim("bit/shift-right", p_bit_shift_right);
      // defprim("bit/arithmetic-shift-right", p_bit_arithmetic_shift_right);
    }
    #+end_src

* *int*

*** p_add

    #+begin_src c
    void p_add() {
      // (cell cell -> int)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a + b);
    }
    #+end_src

*** p_sub

    #+begin_src c
    void p_sub() {
      // (cell cell -> int)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a - b);
    }
    #+end_src

*** p_mul

    #+begin_src c
    void p_mul() {
      // (cell cell -> int)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a * b);
    }
    #+end_src

*** p_div

    #+begin_src c
    void p_div() {
      // (cell cell -> int)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a / b);
    }
    #+end_src

*** p_mod

    #+begin_src c
    void p_mod() {
      // (cell cell -> int)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a % b);
    }
    #+end_src

*** p_n_eq_p

    #+begin_src c
    void p_n_eq_p() {
      // (a ... b ... n -> bool)
      cell n = as_pop();
      cell old_n = n;
      cell* cursor1 = (as + as_pointer - n);
      cell* cursor2 = (as + as_pointer - n - n);
      while (n > 0) {
        if (cursor1[n-1] != cursor2[n-1]) {
          as_pointer = as_pointer - old_n - old_n;
          as_push(false);
          return;
        }
        n--;
      }
      as_pointer = as_pointer - old_n - old_n;
      as_push(true);
    }
    #+end_src

*** p_eq_p

    #+begin_src c
    void p_eq_p() {
      // (cell cell -> bool)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a == b);
    }
    #+end_src

*** p_gt_p

    #+begin_src c
    void p_gt_p() {
      // (cell cell -> bool)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a > b);
    }
    #+end_src

*** p_lt_p

    #+begin_src c
    void p_lt_p() {
      // (cell cell -> bool)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a < b);
    }
    #+end_src

*** p_gteq_p

    #+begin_src c
    void p_gteq_p() {
      // (cell cell -> bool)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a >= b);
    }
    #+end_src

*** p_lteq_p

    #+begin_src c
    void p_lteq_p() {
      // (cell cell -> bool)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a <= b);
    }
    #+end_src

*** k_int

    #+begin_src c
    jo read_jo();

    void k_int() {
      // ([io] -> [compile])
      while (true) {
        jo s = read_jo();
        if (s == str2jo(")")) {
          break;
        }
        else if (int_string_p(jo2str(s))) {
          here(str2jo("i-lit"));
          here(string_to_dec(jo2str(s)));
        }
        else {
          printf("meet non-cell string in (int ...) : %s", jo2str(s));
          break;
        }
      }
    }
    #+end_src

*** k_bin

    #+begin_src c
    void k_bin() {
      // ([io] -> [compile])
      while (true) {
        jo s = read_jo();
        if (s == str2jo(")")) {
          break;
        }
        else if (int_string_p(jo2str(s))) {
          here(str2jo("i-lit"));
          here(string_to_bin(jo2str(s)));
        }
        else {
          printf("meet non-cell string in (int ...) : %s", jo2str(s));
          break;
        }
      }
    }
    #+end_src

*** k_oct

    #+begin_src c
    void k_oct() {
      // ([io] -> [compile])
      while (true) {
        jo s = read_jo();
        if (s == str2jo(")")) {
          break;
        }
        else if (int_string_p(jo2str(s))) {
          here(str2jo("i-lit"));
          here(string_to_oct(jo2str(s)));
        }
        else {
          printf("meet non-cell string in (int ...) : %s", jo2str(s));
          break;
        }
      }
    }
    #+end_src

*** k_hex

    #+begin_src c
    void k_hex() {
      // ([io] -> [compile])
      while (true) {
        jo s = read_jo();
        if (s == str2jo(")")) {
          break;
        }
        else if (int_string_p(jo2str(s))) {
          here(str2jo("i-lit"));
          here(string_to_hex(jo2str(s)));
        }
        else {
          printf("meet non-cell string in (int ...) : %s", jo2str(s));
          break;
        }
      }
    }
    #+end_src

*** p_print_int

    #+begin_src c
    void p_print_int() {
      // (cell -> [io])
      printf("%ld", as_pop());
    }
    #+end_src

*** p_dot

    #+begin_src c
    void p_dot() {
      // (cell -> [io])
      printf("%ld ", as_pop());
    }
    #+end_src

*** export_int

    #+begin_src c
    void export_int() {
      defprim("add", p_add);
      defprim("sub", p_sub);

      defprim("mul", p_mul);
      defprim("div", p_div);
      defprim("mod", p_mod);

      defprim("neg", p_not);

      defprim("n-eq?", p_n_eq_p);

      defprim("eq?", p_eq_p);
      defprim("gt?", p_gt_p);
      defprim("lt?", p_lt_p);
      defprim("gteq?", p_gteq_p);
      defprim("lteq?", p_lteq_p);

      defprim("int", k_int);
      defprim("dec", k_int);
      defprim("bin", k_bin);
      defprim("oct", k_oct);
      defprim("hex", k_hex);

      defprim("print-int", p_print_int);
      defprim("dot", p_dot);
    }
    #+end_src

* *memory*

*** p_allocate

    #+begin_src c
    void p_allocate () {
      // (size -> addr)
      as_push(calloc(as_pop(), 1));
    }
    #+end_src

*** p_free

    #+begin_src c
    void p_free () {
      // (addr ->)
      free(as_pop());
    }
    #+end_src

*** k_var

    #+begin_src c
    void k_var() {
      // ([io] -> [compile])
      here(str2jo("i-lit"));
      jo index = read_jo();
      here(&(jotable[index].value.cell));
      k_ignore();
    }
    #+end_src

*** p_set

    #+begin_src c
    void p_set() {
      // (cell addr ->)
      cell* address = as_pop();
      cell value = as_pop();
      address[0] = value;
    }
    #+end_src

*** p_get

    #+begin_src c
    void p_get() {
      // (addr -> cell)
      cell* address = as_pop();
      as_push(address[0]);
    }
    #+end_src

*** p_set_byte

    #+begin_src c
    void p_set_byte() {
      // (cell addr ->)
      char* address = as_pop();
      cell value = as_pop();
      address[0] = value;
    }
    #+end_src

*** p_get_byte

    #+begin_src c
    void p_get_byte() {
      // (addr -> cell)
      char* address = as_pop();
      as_push(address[0]);
    }
    #+end_src

*** export_memory

    #+begin_src c
    void export_memory() {
      defprim("allocate", p_allocate);
      defprim("free", p_free);
      defprim("var", k_var);
      defprim("set", p_set);
      defprim("get", p_get);
      defprim("set-byte", p_set_byte);
      defprim("get-byte", p_get_byte);
    }
    #+end_src

* read_char

*** reading_stack

    #+begin_src c
    typedef FILE* reading_stack_t[64];

    reading_stack_t reading_stack;
    cell reading_stack_base = 0;
    cell reading_stack_pointer = 0;

    void reading_stack_push(FILE* value) {
      reading_stack[reading_stack_pointer] = value;
      reading_stack_pointer++;
    }

    FILE* reading_stack_pop() {
      reading_stack_pointer--;
      return reading_stack[reading_stack_pointer];
    }

    FILE* reading_stack_tos() {
      return reading_stack[reading_stack_pointer - 1];
    }

    bool reading_stack_empty_p() {
      return reading_stack_pointer == reading_stack_base;
    }
    #+end_src

*** read_char

    #+begin_src c
    char read_char() {
      if (reading_stack_empty_p()) {
        return fgetc(stdin);
      }
      else {
        char c = fgetc(reading_stack_tos());
        if (c == EOF) {
          fclose(reading_stack_pop());
          return read_char();
        }
        else {
          return c;
        }
      }
    }
    #+end_src

*** unread_char

    #+begin_src c
    void unread_char(char c) {
      if (reading_stack_empty_p()) {
        ungetc(c, stdin);
      }
      else {
        ungetc(c, reading_stack_tos());
      }
    }
    #+end_src

* *jo*

*** loading_stack

    - a hook for read_jo

    #+begin_src c
    typedef struct {
      jo nick;
      jo name;
    } alias;

    typedef alias* loading_stack_t[64];

    cell alias_record_size = 1024;

    alias loading_stack_area[64][1024];

    loading_stack_t loading_stack;
    cell loading_stack_base = 0;
    cell loading_stack_pointer = 0;

    void loading_stack_push(alias* value) {
      loading_stack[loading_stack_pointer] = value;
      loading_stack_pointer++;
    }

    alias* loading_stack_pop() {
      loading_stack_pointer--;
      return loading_stack[loading_stack_pointer];
    }

    alias* loading_stack_tos() {
      return loading_stack[loading_stack_pointer - 1];
    }

    bool loading_stack_empty_p() {
      return loading_stack_pointer == loading_stack_base;
    }

    void init_loading_stack() {
      alias record[alias_record_size];
      alias a = {.nick = 0, .name = 0};
      record[0] = a;
      loading_stack_push(record);
    }
    #+end_src

*** alias_add

    #+begin_src c
    void alias_add(jo nick, jo name) {
      alias* alias_record = loading_stack_tos();
      cell i = 0;
      while (i < alias_record_size) {
        if (alias_record[i].nick == 0 &&
            alias_record[i].name == 0) {
          alias_record[i].nick = nick;
          alias_record[i].name = name;
          alias_record[i+1].nick = 0;
          alias_record[i+1].name = 0;
          return;
        }
        else {
          i++;
        }
      }
      printf("alias_add fail alias_record is full\n");
    }
    #+end_src

*** alias_find

    #+begin_src c
    jo alias_find(jo nick) {
      // return 0 -- not found
      alias* alias_record = loading_stack_tos();
      cell i = 0;
      while (true) {
        if (alias_record[i].nick == 0 &&
            alias_record[i].name == 0) {
          return 0;
        }
        else if (alias_record[i].nick == nick) {
          return alias_record[i].name;
        }
        else {
          i++;
        }
      }
    }
    #+end_src

*** read_jo_without_prefix

    #+begin_src c
    jo read_jo_without_prefix() {
      // ([io] -> jo)
      char buf[1024];
      cell cur = 0;
      cell collecting = false;
      char c;
      char go = true;
      while (go) {
        c = read_char();
        if (!collecting) {
          if (isspace(c)) {
            // do nothing
          }
          else {
            collecting = true;
            buf[cur] = c;
            cur++;
            if (isbarcket(c)) {
              go = false;
            }
          }
        }
        else {
          if (isbarcket(c) ||
              isspace(c)) {
            unread_char(c);
            go = false;
          }
          else {
            buf[cur] = c;
            cur++;
          }
        }
      }
      buf[cur] = 0;
      return str2jo(buf);
    }
    #+end_src

*** read_jo

    #+begin_src c
    jo read_jo() {
      // ([io] -> jo)
      jo jo0 = read_jo_without_prefix();
      jo jo1 = alias_find(jo0);
      if (jo1 != 0) {
        return jo1;
      }
      else {
        return jo0;
      }
    }
    #+end_src

*** p_read_jo_without_prefix

    #+begin_src c
    void p_read_jo_without_prefix() {
      as_push(read_jo_without_prefix());
    }
    #+end_src

*** p_read_jo

    #+begin_src c
    void p_read_jo() {
      as_push(read_jo());
    }
    #+end_src

*** cat_2_jo

    #+begin_src c
    jo cat_2_jo(jo x, jo y) {
      char str[2 * 1024];
      str[0] = 0;
      strcat(str, jo2str(x));
      strcat(str, jo2str(y));
      return str2jo(str);
    }
    #+end_src

*** cat_3_jo

    #+begin_src c
    jo cat_3_jo(jo x, jo y, jo z) {
      char str[3 * 1024];
      str[0] = 0;
      strcat(str, jo2str(x));
      strcat(str, jo2str(y));
      strcat(str, jo2str(z));
      return str2jo(str);
    }
    #+end_src

*** p_jo_used_p

    #+begin_src c
    void p_jo_used_p() {
      // (jo -> bool)
      jo jo = as_pop();
      as_push(jotable_entry_used(jotable[jo]));
    }
    #+end_src

*** p_jo_to_string

    #+begin_src c
    void p_jo_to_string() {
      // (jo -> string)
      jo jo = as_pop();
      as_push(jo2str(jo));
    }
    #+end_src

*** p_string_length_to_jo

    #+begin_src c
    void p_string_length_to_jo() {
      // (string length -> jo)
      cell len = as_pop();
      cell str = as_pop();
      char buffer[2 * 1024];
      strncpy(buffer, str, len);
      buffer[len] = 0;
      as_push(str2jo(buffer));
    }
    #+end_src

*** p_string_to_jo

    #+begin_src c
    void p_string_to_jo() {
      // (string -> jo)
      string str = as_pop();
      as_push(str2jo(str));
    }
    #+end_src

*** p_null

    #+begin_src c
    void p_null() {
      as_push(str2jo("null"));
    }
    #+end_src

*** k_jo

    #+begin_src c
    void k_jo() {
      // ([io] -> [compile])
      while (true) {
        jo s = read_jo();
        if (s == str2jo("(")) {
          eval_key(read_jo());
        }
        else if (s == str2jo(")")) {
          break;
        }
        else {
          here(str2jo("i-lit"));
          here(s);
        }
      }
    }
    #+end_src

*** export_jo

    #+begin_src c
    void export_jo() {
      defprim("null", p_null);
      defprim("read-jo", p_read_jo);
      defprim("read-jo-without-prefix", p_read_jo_without_prefix);
      defprim("jo-used?", p_jo_used_p);
      defprim("jo->string", p_jo_to_string);
      defprim("string->jo", p_string_to_jo);
      defprim("string/length->jo", p_string_length_to_jo);
      defprim("jo", k_jo);
    }
    #+end_src

* *string*

*** k_one_string

    #+begin_src c
    void k_one_string() {
      // ([io] -> [compile])
      char buffer[1024 * 1024];
      cell cursor = 0;
      while (true) {
        char c = read_char();
        if (c == '"') {
          buffer[cursor] = 0;
          cursor++;
          break;
        }
        else {
          buffer[cursor] = c;
          cursor++;
        }
      }
      string str = malloc(cursor);
      strcpy(str, buffer);
      here(str2jo("i-lit"));
      here(str);
    }
    #+end_src

*** k_string

    #+begin_src c
    void k_string() {
      // ([io] -> [compile])
      while (true) {
        jo s = read_jo();
        if (s == str2jo(")")) {
          return;
        }
        else if (s == str2jo("\"")) {
          k_one_string();
        }
        else {
          // do nothing
        }
      }
    }
    #+end_src

*** p_print_string

    #+begin_src c
    void p_print_string() {
      // (string -> [io])
      printf("%s", as_pop());
    }
    #+end_src

*** export_string

    #+begin_src c
    void export_string() {
      defprim("string", k_string);
      defprim("print-string", p_print_string);
    }
    #+end_src

* *file*

*** p_read_file

    #+begin_src c
    void p_read_file() {
      // (string addr number -> number)
      cell limit = as_pop();
      cell buffer = as_pop();
      cell path = as_pop();
      FILE* fp = fopen(path, "r");
      if(!fp) {
        perror("p_read_file file to open file");
        return;
      }
      cell readed_counter = fread(buffer, 1, limit, fp);
      fclose(fp);
      as_push(readed_counter);
    }
    #+end_src

*** file_readable_p

    #+begin_src c
    bool file_readable_p(string path) {
      FILE* fp = fopen(path, "r");
      if (!fp) {
        return false;
      }
      else {
        fclose(fp);
        return true;
      }
    }
    #+end_src

*** dir_ok_p

    #+begin_src c
    bool dir_ok_p(string path) {
      DIR* dir = opendir(path);
      if (!dir) {
        return false;
      }
      else {
        closedir(dir);
        return true;
      }
    }
    #+end_src

*** export_file

    #+begin_src c
    void export_file() {
      defprim("read-file", p_read_file);
    }
    #+end_src

* *system*

*** p_getcwd

    #+begin_src c
    void p_getcwd() {
      // (-> string)
      char buf[1024];
      as_push(getcwd(buf, 1024));
    }
    #+end_src

*** export_system

    #+begin_src c
    void export_system() {
      defprim("getcwd", p_getcwd);
    }
    #+end_src

* *module*

*** module_record

    - just record what modules are loaded
      and their meta-data

    #+begin_src c
    typedef struct {
      jo name;
      jo dir;
      jo* export;
    } module;

    typedef module module_record_t[1024];

    module_record_t module_record;
    cell module_record_base = 0;
    cell module_record_pointer = 0;

    void module_record_push(module value) {
      module_record[module_record_pointer] = value;
      module_record_pointer++;
    }

    bool module_record_empty_p() {
      return module_record_pointer == module_record_base;
    }

    bool module_record_find(jo name) {
      cell i = 0;
      while (i < module_record_pointer) {
        if (name == module_record[i].name) {
          return true;
        }
        i++;
      }
      return false;
    }

    jo* module_record_get_export(jo name) {
      // 0 -- not found
      cell i = module_record_base;
      while (i < module_record_pointer) {
        if (name == module_record[i].name) {
          return module_record[i].export;
        }
        i++;
      }
      return false;
    }

    void module_record_set_export(jo name, jo* export) {
      cell i = module_record_base;
      while (i < module_record_pointer) {
        if (name == module_record[i].name) {
          module_record[i].export = export;
          return;
        }
        i++;
      }
      printf("module_record_set_export fail\n",
             "can not find module: %s\n", jo2str(name));
    }
    #+end_src

*** module_stack

    - just record what modules are loaded
      and their meta-data

    #+begin_src c
    typedef module module_stack_t[1024];

    module_stack_t module_stack;
    cell module_stack_base = 0;
    cell module_stack_pointer = 0;

    void module_stack_push(module value) {
      module_stack[module_stack_pointer] = value;
      module_stack_pointer++;
    }

    bool module_stack_empty_p() {
      return module_stack_pointer == module_stack_base;
    }

    module module_stack_pop() {
      module_stack_pointer--;
      return module_stack[module_stack_pointer];
    }

    module module_stack_tos() {
      return module_stack[module_stack_pointer - 1];
    }
    #+end_src

*** load_file

    #+begin_src c
    void load_file(string path) {
      // [reading_stack]
      FILE* fp = fopen(path, "r");
      if(!fp) {
        perror("File opening failed");
        printf("load_file fail : %s\n", path);
        return;
      }
      reading_stack_push(fp);
    }
    #+end_src

*** k_one_include

    #+begin_src c
    void k_one_include() {
      // ([io] -> *)
      char buffer[1024 * 1024];
      cell cursor = 0;
      while (true) {
        char c = read_char();
        if (c == '"') {
          buffer[cursor] = 0;
          cursor++;
          break;
        }
        else {
          buffer[cursor] = c;
          cursor++;
        }
      }
      load_file(buffer);
    }
    #+end_src

*** k_include

    #+begin_src c
    void k_include() {
      // ([io] -> [compile])
      while (true) {
        jo s = read_jo();
        if (s == str2jo(")")) {
          return;
        }
        else if (s == str2jo("(")) {
          eval_key(read_jo());
        }
        else if (s == str2jo("\"")) {
          k_one_include();
        }
        else {
          // do nothing
        }
      }
    }
    #+end_src

*** get_module_path & get_module_dir

    #+begin_src c
    string user_module_dir = "/.jojo/module/";
    string system_module_dir = "";

    jo get_module_path(jo name) {
      // return 0 -- not found
      char path[4 * 1024];
      path[0] = 0;
      strcat(path, getenv("HOME"));
      strcat(path, user_module_dir);
      strcat(path, jo2str(name));
      strcat(path, "/");
      strcat(path, "module.jo");
      if (file_readable_p(path)) {
        return str2jo(path);
      }
      else {
        return 0;
      }
    }

    jo get_module_dir(jo name) {
      // return 0 -- not found
      char path[4 * 1024];
      path[0] = 0;
      strcat(path, getenv("HOME"));
      strcat(path, user_module_dir);
      strcat(path, jo2str(name));
      strcat(path, "/");
      if (dir_ok_p(path)) {
        return str2jo(path);
      }
      else {
        return 0;
      }
    }
    #+end_src

*** import_module

    #+begin_src c
    void import_module(jo name) {
      jo* export = module_record_get_export(name);
      if (export == 0) {
        printf("import_module fail to import: %s\n", jo2str(name));
        return;
      }
      cell i = 0;
      while (export[i] != 0) {
        jo new_jo = cat_3_jo(name,
                             str2jo("/"),
                             export[i]);
        alias_add(export[i], new_jo);
        i++;
      }
    }
    #+end_src

*** k_dep_load

    #+begin_src c
    bool k_dep_load(jo name) {
      jo module_path = get_module_path(name);
      jo module_dir = get_module_dir(name);
      if (module_path == 0) {
        return false;
      }

      jo export[1];
      export[0] = 0;
      module m = {
        .name = name,
        .dir = module_dir,
        .export = export
      };
      module_record_push(m);
      module_stack_push(m);

      alias a = {.nick = 0, .name = 0};
      loading_stack_area[loading_stack_pointer][0] = a;
      loading_stack_push(loading_stack_area[loading_stack_pointer]);

      load_file(jo2str(module_path));

      return true;
    }
    #+end_src

*** k_dep

    #+begin_src c
    void k_dep() {
      // ([io] -> [loading_stack])
      jo prefix = read_jo_without_prefix();
      jo version = read_jo_without_prefix();
      jo name = cat_3_jo(prefix, str2jo("/"), version);
      if (!module_record_find(name)) {
        bool result = k_dep_load(name);
        if (result == false) {
          printf("k_dep fail to load module : %s\n", jo2str(name));
          k_ignore();
        }
        else {
          while (true) {
            jo s = read_jo();
            if (s == str2jo("(")) {
              eval_key(read_jo());
            }
            else if (s == str2jo(")")) {
              loading_stack_pop();
              module_stack_pop();
              import_module(name);
              break;
            }
            else {
              // do nothing
            }
          }
        }
      }
    }
    #+end_src

*** k_module

    #+begin_src c
    void k_module() {
      // ([io] -> [loading_stack_tos])
      jo prefix = read_jo_without_prefix();
      jo version = read_jo_without_prefix();
      jo name = cat_3_jo(prefix, str2jo("/"), version);
      // ><><>< check module name

      jo* export = compiling_stack_tos();
      while (true) {
        jo s = read_jo_without_prefix();
        if (s == str2jo(")")) {
          here(0);
          module_record_set_export(name, export);
          return;
        }
        else if (!alias_find(s) == 0) {
          printf("k_module fail, alias used : %s\n", jo2str(s));
          k_ignore();
          return;
        }
        else {
          here(s);
        }
      }
    }
    #+end_src

*** one_module_report

    #+begin_src c
    void one_module_report(module m) {
      printf("  - %s -- %s\n", jo2str(m.name), jo2str(m.dir));
      cell i = 0;
      while (m.export[i] != 0) {
        printf("    %s\n", jo2str(m.export[i]));
        i++;
      }
    }
    #+end_src

*** module_report

    #+begin_src c
    void module_report() {
      printf("- module_report\n");
      cell i = module_record_base;
      while (i < module_record_pointer) {
        one_module_report(module_record[i]);
        i++;
      }
    }
    #+end_src

*** export_module

    #+begin_src c
    void export_module() {
      defprim("include", k_include);
      defprim("dep", k_dep);
      defprim("module", k_module);
      defprim("module-report", module_report);
    }
    #+end_src

* *ffi*

*** get_clib

    #+begin_src c
    void* get_clib(string rel_path) {
      char path[2 * 1024];
      path[0] = 0;
      strcat(path, jo2str(module_stack_tos().dir));
      strcat(path, rel_path);
      void* lib = dlopen(path, RTLD_LAZY);
      if (lib == NULL) {
        printf("fail to open library : %s : %s\n",
               path, dlerror());
      };
      return lib;
    }
    #+end_src

*** ccall

    #+begin_src c
    void ccall (string str, void* lib) {
      primitive fun = dlsym(lib, str);
      if (fun == NULL) {
        printf("can not find %s function lib : %s\n",
               str, dlerror());
      };
      fun();
    }
    #+end_src

*** k_one_clib

    #+begin_src c
    void k_one_clib() {
      // ([io] -> [compile])
      char buffer[1024];
      cell cursor = 0;
      while (true) {
        char c = read_char();
        if (c == '"') {
          buffer[cursor] = 0;
          cursor++;
          break;
        }
        else {
          buffer[cursor] = c;
          cursor++;
        }
      }
      ccall("export", get_clib(buffer));
    }
    #+end_src

*** k_clib

    #+begin_src c
    void k_clib() {
      // ([io] -> [compile])
      while (true) {
        jo s = read_jo();
        if (s == str2jo(")")) {
          return;
        }
        else if (s == str2jo("\"")) {
          k_one_clib();
        }
        else {
          // do nothing
        }
      }
    }
    #+end_src

*** export_ffi

    #+begin_src c
    void export_ffi() {
      defprim("clib", k_clib);
    }
    #+end_src

* *top_level*

*** prim_jo_p & fun_jo_p & var_jo_p & used_jo_p

    #+begin_src c
    bool prim_jo_p(jo index) {
      return jotable[index].type == str2jo("primitive");
    }

    bool fun_jo_p(jo index) {
      return jotable[index].type == str2jo("function");
    }

    bool var_jo_p(jo index) {
      return jotable[index].type == str2jo("variable");
    }

    bool used_jo_p(jo index) {
      return
        prim_jo_p(index) ||
        fun_jo_p(index) ||
        var_jo_p(index);
    }
    #+end_src

*** jo_to_jo_in_module

    #+begin_src c
    jo jo_to_jo_in_module(jo alias_jo) {
      if (module_stack_empty_p()) {
        return alias_jo;
      }
      else {
        jo new_jo = cat_3_jo(module_stack_tos().name,
                             str2jo("/"),
                             alias_jo);
        alias_add(alias_jo, new_jo);
        return new_jo;
      }
    }
    #+end_src

*** read_jo_in_module

    #+begin_src c
    jo read_jo_in_module() {
      jo_to_jo_in_module(read_jo());
    }
    #+end_src

*** k_defun

***** defun_record

      #+begin_src c
      jo defun_record[64 * 1024];
      cell defun_record_counter = 0;
      #+end_src

***** p_defun_record

      #+begin_src c
      void p_defun_record() {
        // (-> addr)
        as_push(defun_record);
      }
      #+end_src

***** defun_report

      #+begin_src c
      void defun_report() {
        printf("- defun_report // counter : %ld\n", defun_record_counter);
        cell i = 0;
        while (i < defun_record_counter) {
          printf("  %s\n", jo2str(defun_record[i]));
          i++;
        }
        printf("\n");
      }
      #+end_src

***** defun_stack

      #+begin_src c
      typedef jo defun_stack_t[1024];

      defun_stack_t defun_stack;
      cell defun_stack_base = 0;
      cell defun_stack_pointer = 0;

      void defun_stack_push(jo* value) {
        defun_stack[defun_stack_pointer] = value;
        defun_stack_pointer++;
      }

      jo* defun_stack_pop() {
        defun_stack_pointer--;
        return defun_stack[defun_stack_pointer];
      }

      void defun_stack_inc() {
        defun_stack[defun_stack_pointer - 1] =
          defun_stack[defun_stack_pointer - 1] + 1;
      }


      jo* defun_stack_tos() {
        return defun_stack[defun_stack_pointer - 1];
      }

      bool defun_stack_empty_p() {
        return defun_stack_pointer == defun_stack_base;
      }
      #+end_src

***** k_defun

      #+begin_src c
      void k_compile_jojo();

      void k_defun() {
        // ([io] -> [compile] [jotable])
        jo index = read_jo_in_module();
        if (used_jo_p(index)) {
          printf("- defun can not re-define : %s\n", jo2str(index));
          printf("  it already defined as : %s\n", jo2str(jotable[index].type));
          k_ignore();
          return;
        }
        defun_stack_push(index);
        defun_record[defun_record_counter] = index;
        defun_record_counter++;
        defun_record[defun_record_counter] = 0;
        jo* array = compiling_stack_tos();
        k_compile_jojo();
        here(str2jo("end"));
        jotable[index].type = str2jo("function");
        jotable[index].value.jojo.size = compiling_stack_tos() - array;
        jotable[index].value.jojo.array = array;
        defun_stack_pop();
      }
      #+end_src

*** k_declare

***** note

      - no compile before define
        declare helps mutual recursive function

***** k_one_declare

      #+begin_src c
      void k_one_declare() {
        jo index = read_jo_in_module();
        jotable[index].type = str2jo("declared");
        k_ignore();
      }
      #+end_src

***** k_declare

      #+begin_src c
      void k_declare() {
        while (true) {
          jo s = read_jo();
          if (s == str2jo(")")) {
            return;
          }
          else if (s == str2jo("(")) {
            k_one_declare();
          }
          else {
            // do nothing
          }
        }
      }
      #+end_src

*** k_run

    #+begin_src c
    void k_run() {
      // ([io] -> *)
      jo array[64 * 1024];
      compiling_stack_push(array);
      while (true) {
        jo s = read_jo();
        if (s == str2jo("(")) {
          eval_key(read_jo());
        }
        else if (s == str2jo(")")) {
          here(str2jo("end"));
          break;
        }
        else {
          here(s);
        }
      }
      compiling_stack_pop();
      eval_jojo(array);
    }
    #+end_src

*** k_defvar

***** defvar_record

      #+begin_src c
      jo defvar_record[64 * 1024];
      cell defvar_record_counter = 0;
      #+end_src

***** p_defvar_record

      #+begin_src c
      void p_defvar_record() {
        // (-> addr)
        as_push(defvar_record);
      }
      #+end_src

***** defvar_report

      #+begin_src c
      void defvar_report() {
        printf("- defvar_report // counter : %ld\n", defvar_record_counter);
        cell i = 0;
        while (i < defvar_record_counter) {
          printf("  %s\n", jo2str(defvar_record[i]));
          i++;
        }
        printf("\n");
      }
      #+end_src

***** k_defvar

      #+begin_src c
      void k_defvar() {
        // ([io] -> [compile] [jotable])
        jo index = read_jo_in_module();
        if (used_jo_p(index)) {
          printf("- defvar can not re-define : %s\n", jo2str(index));
          printf("  it already defined as : %s\n", jo2str(jotable[index].type));
          k_ignore();
          return;
        }
        defvar_record[defvar_record_counter] = index;
        defvar_record_counter++;
        defvar_record[defvar_record_counter] = 0;
        k_run();
        jotable_set_cell(index, as_pop());
      }
      #+end_src

*** p_top_repl

    #+begin_src c
    void p_top_repl() {
      // ([io] -> *)
      while (true) {
        jo s = read_jo();
        if (s == str2jo("(")) {
          eval_key(read_jo());
        }
        else {
          // do nothing
        }
      }
    }
    #+end_src

*** export_top_level

    #+begin_src c
    void export_top_level() {
      defprim("defun-record", p_defun_record);
      defprim("defun-report", defun_report);

      defprim("defun", k_defun);

      defprim("declare", k_declare);

      defprim("run", k_run);

      defprim("defvar-record", p_defvar_record);
      defprim("defvar-report", defvar_report);
      defprim("defvar", k_defvar);

      defprim("top-repl", p_top_repl);
    }
    #+end_src

* *keyword*

*** k_ignore

    #+begin_src c
    void k_ignore() {
      // ([io] ->)
      while (true) {
        jo s = read_jo();
        if (s == str2jo("(")) {
          k_ignore();
        }
        if (s == str2jo(")")) {
          break;
        }
      }
    }
    #+end_src

*** compile_jojo_until_meet_jo

    #+begin_src c
    void compile_jojo_until_meet_jo(jo end) {
      // ([io] -> [compile])
      while (true) {
        jo s = read_jo();
        if (s == str2jo("(")) {
          eval_key(read_jo());
        }
        else if (s == end) {
          break;
        }
        else if (jotable_entry_used(jotable[s]) ||
                 defun_stack_empty_p() ||
                 defun_stack_tos() == s) {
          here(s);
        }
        else {
          // no compile before define
          printf("- k_compile_jojo undefined : %s\n", jo2str(s));
          k_ignore();
          return;
        }
      }
    }
    #+end_src

*** k_compile_jojo_until_meet_jo

    #+begin_src c
    void k_compile_jojo_until_meet_jo() {
      compile_jojo_until_meet_jo(as_pop());
    }
    #+end_src

*** k_compile_jojo

    #+begin_src c
    void k_compile_jojo() {
      // ([io] -> [compile])
      compile_jojo_until_meet_jo(str2jo(")"));
    }
    #+end_src

*** k_if

    - (if a b p? -> c d)

    - a b p?
      [jump] jumk_if_false
      c d
      :jump

    - because the use of as_snapshot
      bar can not be nested in antecedent

    #+begin_src c
    void k_if() {
      // ([io] -> [compile])
      compile_jojo_until_meet_jo(str2jo("->"));
      here(str2jo("i-lit"));
      cell* offset_place = compiling_stack_tos();
      compiling_stack_inc();
      here(str2jo("jump-if-false"));
      k_compile_jojo();
      offset_place[0] = compiling_stack_tos();
    }
    #+end_src

*** k_tail_call

    #+begin_src c
    void k_tail_call() {
      // ([io] -> [compile])
      // no check for "no compile before define"
      here(str2jo("i-tail-call"));
      jo s = read_jo();
      here(s);
      k_ignore();
    }
    #+end_src

*** k_loop

    #+begin_src c
    void k_loop() {
      here(str2jo("i-tail-call"));
      here(defun_stack_tos());
      k_ignore();
    }
    #+end_src

*** k_recur

    #+begin_src c
    void k_recur() {
     here(defun_stack_tos());
     k_ignore();
    }
    #+end_src

*** p_compiling_stack_tos

    #+begin_src c
    void p_compiling_stack_tos() {
      as_push(compiling_stack_tos());
    }
    #+end_src

*** i_jojo

    #+begin_src c
    void i_jojo() {
      // ([rs] -> int)
      jo* function_body = rs_pop();
      rs_push(function_body[0]);
      as_push(function_body + 1);
    }
    #+end_src

*** k_jojo

    #+begin_src c
    void k_jojo() {
      // ([io] -> [compile])
      here(str2jo("i-jojo"));
      cell* offset_place = compiling_stack_tos();
      compiling_stack_inc();
      k_compile_jojo();
      here(str2jo("end"));
      offset_place[0] = compiling_stack_tos();
    }
    #+end_src

*** export_keyword

    #+begin_src c
    void export_keyword() {
      defprim(":", k_ignore);
      defprim("note", k_ignore);

      defprim("compiling-stack-tos", p_compiling_stack_tos);
      defprim("compiling-stack-inc", compiling_stack_inc);

      defprim("if", k_if);
      defprim("do", k_compile_jojo);
      defprim("compile-jojo-until-meet-jo", k_compile_jojo_until_meet_jo);
      defprim("else", k_compile_jojo);
      defprim("tail-call", k_tail_call);
      defprim("loop", k_loop);
      defprim("recur", k_recur);

      defprim("jojo", k_jojo);
      defprim("i-jojo", i_jojo);
    }
    #+end_src

* *misc*

*** do_nothing

    #+begin_src c
    void do_nothing() {
    }
    #+end_src

*** p_here

    #+begin_src c
    void p_here() {
      here(as_pop());
    }
    #+end_src

*** bar-ket

    #+begin_src c
    void p_round_bar() { as_push(str2jo("(")); }
    void p_round_ket() { as_push(str2jo(")")); }
    void p_square_bar() { as_push(str2jo("[")); }
    void p_square_ket() { as_push(str2jo("]")); }
    void p_flower_bar() { as_push(str2jo("{")); }
    void p_flower_ket() { as_push(str2jo("}")); }
    void p_double_quote() { as_push(str2jo("\"")); }
    #+end_src

*** p_cell_size

    #+begin_src c
    void p_cell_size() {
      // (-> cell)
      as_push(sizeof(cell));
    }
    #+end_src

*** p_newline

    #+begin_src c
    void p_newline() {
      printf("\n");
    }
    #+end_src

*** export_mise

    #+begin_src c
    void export_mise() {
      defprim("here", p_here);
      defprim("jo/apply", p_jo_apply);
      defprim("apply", p_apply);
      defprim("jotable-report", jotable_report);

      defprim("round-bar", p_round_bar);
      defprim("round-ket", p_round_ket);
      defprim("square-bar", p_square_bar);
      defprim("square-ket", p_square_ket);
      defprim("flower-bar", p_flower_bar);
      defprim("flower-ket", p_flower_ket);
      defprim("double-quote", p_double_quote);

      defprim("cell-size", p_cell_size);
      defprim("defprim-report", defprim_report);
      defprim("newline", p_newline);
    }
    #+end_src

* *play*

*** p1

    #+begin_src c
    void p1() {
      printf("- p1\n");
      printf("  %ld %ld %ld\n", sizeof(void*), sizeof(cell), sizeof(unsigned));
      printf("  %ld %ld\n", sizeof((cell)-1), sizeof(-1));
      printf("  %x %x\n", 1<<sizeof(cell), 32>>6);
      printf("  %x %x %x\n", -1>>2, (cell)-1>>2, (unsigned)-1>>2);
      printf("  %ld %ld\n", string_to_bin("1000"), string_to_hex("ffff"));
      printf("  %ld %ld %ld %ld\n", '0', '1', 'A', 'a');
    }
    #+end_src

*** p2

    #+begin_src c
    void p2() {
      printf("- p2\n");
    }
    #+end_src

*** p3

    #+begin_src c
    cell string_to_sum_test(string str) {
      cell sum = 0;
      cell max_step = 10;
      cell i = 0;
      while (i < strlen(str)) {
        sum = sum + ((unsigned char) str[i]) * (2 << min(i, max_step));
        printf("| char: %ld | unsigned char: %ld | sum: %ld |\n", str[i], (unsigned char) str[i], sum);
        i++;
      }
      return sum;
    }

    void p3() {
      printf("- p3\n");
      printf("  %ld\n", string_to_sum_test("abcabcabc"));
      printf("  %ld\n", string_to_sum_test(""));
      printf("  %ld\n", string_to_sum_test(""));
    }
    #+end_src

*** export_play

    #+begin_src c
    void export_play() {
      defprim("p1", p1);
      defprim("p2", p2);
      defprim("p3", p3);
    }
    #+end_src

* epilog

*** init_top_repl

    #+begin_src c
    void init_top_repl() {
      init_jotable();
      init_compiling_stack();
      init_loading_stack();

      export_stack_operation();
      export_ending();
      export_control();
      export_bool();
      export_bit();
      export_int();
      export_memory();
      export_jo();
      export_string();
      export_file();
      export_keyword();
      export_system();
      export_module();
      export_ffi();
      export_top_level();
      export_mise();
      export_play();
    }
    #+end_src

*** main

    #+begin_src c
    int main(int argc, string* argv) {
      init_top_repl();
      if (argc != 1) {
        load_file(argv[1]);
      }
      p_top_repl();
    }
    #+end_src
