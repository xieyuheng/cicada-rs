#+property: tangle libjojo.c
#+title:  jojo
- all functions about output should respect writing_stack
  [to use it as an implicit argument]
- readable check for input_stack
  writable check for output_stack
- command in repl
  to use it as a shell
- fix point_return_point
* [todo-stack]

  - unread

  - low-level syntax macro
    [at reader level]

  - multiple-dispatch

  - c-like struct
    - by c struct, stack in c is easy.
      the c-like syntax we designed for jojo
      also shall let us implement stack in jojo easily.

* [todo-list]

  - trace and untrace a jo

  - delimited continuation
    to control return_stack [and data_stack]

  - concurrent
    use list to implement return_stack and data_stack in jojo
    thus each group of stacks is a light weight process

* [maybe]

  - make BLOCK_SIZE local to object

* [note]

*** interface convention

    - before trying to get something from somewhere,
      first ask if it is there at all.

    - this convention can only be used
      when condition race will not occur,
      or when condition race is not important.

*** important common sense

    - all programs are changings of state of machine

    - syntax-checker, type-checker, compiler are all special interpreters

*** threaded code interpreter

    - types of threaded code interpreter :
      1. indirect threaded code
      2. direct threaded code
      3. token threaded code
      4. subroutine threaded code
      5. dynamic threaded code
         [jotable] [symbol-hash-table [of lisp]]

    - overhead of eval
      base_pointer test [to be able to return to c function]
      step_flag test

    - overhead of jo_apply
      dispatching [dynamic threaded code]

*** possible static type system

    - type comment in jojo and c code :
      1. change of data_stack -- [...] -> [...]
      2. other effect -- {}
         which can occur in any position in a type comment

    - the type comment in the code suggest a static type system.

      a static type system
      and a compiled verison of jojo
      might be implemented,

      but an untyped and a dynamic typed level are also important.

*** levels of languages

    1. untyped -- ffi to c [thus as low as c]
    2. dynamic typed -- debug and test
    3. static typed
    4. logic
    5. concurrent
    6. dependent type -- type as proof
    7. algebraic topology and combinatorial topology

*** apply and scope

    - apply will create new scope of local names.

    - thus
      p_compile_jojo will create new scope of local names.

    - by the following we can add pre-setted name to a scope :
      current-local-pointer swap
      (< data) (< tag) (jo self) local-in
      apply-with-local-pointer

    - but we can not use old names in the scope outside this scope.

*** limits

    | name                 | length      | unit          |
    |----------------------+-------------+---------------|
    | jojo_area            | 1024 * 1024 | jo            |
    | jotable              | 97 * 1024   | jotable_entry |
    | name_record          | 16 * 1024   | jo            |
    |----------------------+-------------+---------------|
    | data_stack           | 4 * 1024    | cell          |
    | return_stack         | 4 * 1024    | return_point  |
    | local_record         | 4 * 1024    | local_point   |
    | alias_record         | 1024        | alias_point   |
    |----------------------+-------------+---------------|
    | compiling_stack      |             | jo*           |
    | binding_filter_stack |             | jo            |
    | keyword_stack        |             | alias_pointer |
    | reading_stack        |             | FILE*         |
    | jo_filter_stack      |             | jo            |

*** minimalism

    - to keep the core minimal,
      I only implement the features needed to load other modules.

* header

  #+begin_src c
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <unistd.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <errno.h>
  #include <string.h>
  #include <fcntl.h>
  #include <ctype.h>
  #include <stdint.h>
  #include <dlfcn.h>
  #include <dirent.h>
  #include <signal.h>
  #include <limits.h>
  #include <stdarg.h>
  #+end_src

* type

  #+begin_src c
  typedef enum { false, true } bool;
  // typedef intptr_t cell;
  typedef intmax_t cell;
  typedef uint8_t byte;
  typedef void (* primitive)();
  #+end_src

* utility

*** int

    #+begin_src c
    cell max(cell a, cell b) {
      if (a < b) {
        return b;
      }
      else {
        return a;
      }
    }

    cell min(cell a, cell b) {
      if (a > b) {
        return b;
      }
      else {
        return a;
      }
    }

    cell power(cell a, cell n) {
      cell result = 1;
      while (n >= 1) {
        result = result * a;
        n--;
      }
      return result;
    }
    #+end_src

*** char

    #+begin_src c
    bool isbarcket(char c) {
      return (c == '(' ||
              c == ')' ||
              c == '[' ||
              c == ']' ||
              c == '{' ||
              c == '}' ||
              c == '"');
    }
    #+end_src

*** char_to_nat

    #+begin_src c
    cell char_to_nat(char c) {
      if (c >= '0' && c <= '9') {
        return (c - '0');
      }
      else if (c >= 'A' && c <= 'Z') {
        return (c - 'A') + 10;
      }
      else if (c >= 'a' && c <= 'z') {
        return (c - 'a') + 10;
      }
      else {
        return 0;
      }
    }
    #+end_src

*** string

***** string_equal

      #+begin_src c
      bool string_equal(char* s1, char* s2) {
        if (strcmp(s1, s2) == 0) {
          return true;
        }
        else {
          return false;
        }
      }
      #+end_src

***** nat_string_p

      #+begin_src c
      bool nat_string_p(char* str) {
        cell i = 0;
        while (str[i] != 0) {
          if (!isdigit(str[i])) {
            return false;
            }
          i++;
        }
        return true;
      }
      #+end_src

***** int_string_p

      #+begin_src c
      bool int_string_p(char* str) {
        if (str[0] == '-' ||
            str[0] == '+') {
          return nat_string_p(str + 1);
        }
        else {
          return nat_string_p(str);
        }
      }
      #+end_src

***** string_to_based_nat & string_to_based_int & string_to_int

      #+begin_src c
      cell string_to_based_nat(char* str, cell base) {
        cell result = 0;
        cell len = strlen(str);
        cell i = 0;
        while (i < len) {
          result = result + (char_to_nat(str[i]) * power(base, (len - i - 1)));
          i++;
        }
        return result;
      }

      cell string_to_based_int(char* str, cell base) {
        if (str[0] == '-') {
          return - string_to_based_nat(str, base);
        }
        else {
          return string_to_based_nat(str, base);
        }
      }

      cell string_to_int(char* str) { return string_to_based_int(str, 10); }
      #+end_src

*** error

    #+begin_src c
    reportf(char* format, ...) {
      va_list arg_list;
      va_start(arg_list, format);
      vdprintf(STDERR_FILENO, format, arg_list);
      va_end(arg_list);
    }
    #+end_src

* jotable

*** type

    #+begin_src c
    typedef struct _jotable_entry {
      char *key;
      struct _jotable_entry *tag;
      cell value;
    } jotable_entry;

    typedef jotable_entry *jo;

    // prime table size
    //   1000003   about 976 k
    //   1000033
    //   1000333
    //   100003    about 97 k
    //   100333
    //   997
    #define jotable_size 100003
    jotable_entry jotable[jotable_size];

    // thus (jotable + index) is jo
    #+end_src

*** used_jo_p

    #+begin_src c
    bool used_jo_p(jo jo) {
      return jo->tag != 0;
    }
    #+end_src

*** string_to_sum

    #+begin_src c
    cell string_to_sum(char* str) {
      cell sum = 0;
      cell max_step = 10;
      cell i = 0;
      while (i < strlen(str)) {
        sum = sum + ((byte) str[i]) * (2 << min(i, max_step));
        i++;
      }
      return sum;
    }
    #+end_src

*** jotable_hash

    #+begin_src c
    // a hash an index into jotable
    cell jotable_hash(cell sum, cell counter) {
      return (counter + sum) % jotable_size;
    }
    #+end_src

*** jotable_insert

    #+begin_src c
    p_debug();

    jo jotable_insert(char* key) {
      // in C : [string] -> [jo]
      cell sum = string_to_sum(key);
      cell counter = 0;
      while (true) {
        cell index = jotable_hash(sum, counter);
        jo jo = (jotable + index);
        if (jo->key == 0) {
          key = strdup(key);
          jo->key = key;
          return jo;
        }
        else if (string_equal(key, jo->key)) {
          return jo;
        }
        else if (counter == jotable_size) {
          reportf("- jotable_insert fail\n");
          reportf("  the hash_table is filled\n");
          p_debug();
          return NULL;
        }
        else {
          counter++;
        }
      }
    }
    #+end_src

*** str2jo

    #+begin_src c
    jo str2jo(char* str) {
      return jotable_insert(str);
    }
    #+end_src

*** jo2str

    #+begin_src c
    char* jo2str(jo jo) {
      return jo->key;
    }
    #+end_src

*** literal jo

    #+begin_src c
    jo EMPTY_JO;
    jo TAG_PRIM;
    jo TAG_JOJO;
    jo TAG_PRIM_KEYWORD;
    jo TAG_KEYWORD;
    jo TAG_DATA;

    jo JO_DECLARED;

    jo ROUND_BAR;
    jo ROUND_KET;
    jo SQUARE_BAR;
    jo SQUARE_KET;
    jo FLOWER_BAR;
    jo FLOWER_KET;
    jo DOUBLE_QUOTE;

    jo JO_INS_INT;
    jo JO_INS_JO;
    jo JO_INS_STRING;
    jo JO_INS_BYTE;
    jo JO_INS_BARE_JOJO;
    jo JO_INS_ADDRESS;

    jo JO_INS_JUMP;
    jo JO_INS_JUMP_IF_FALSE;

    jo JO_INS_TAIL_CALL;
    jo JO_INS_LOOP;
    jo JO_INS_RECUR;

    jo JO_NULL;
    jo JO_THEN;
    jo JO_ELSE;

    jo JO_APPLY;
    jo JO_END;

    jo JO_LOCAL_DATA_IN;
    jo JO_LOCAL_DATA_OUT;

    jo JO_LOCAL_TAG_IN;
    jo JO_LOCAL_TAG_OUT;

    jo JO_LOCAL_IN;
    jo JO_LOCAL_OUT;
    #+end_src

* stack

*** stack_link

    #+begin_src c
    typedef struct _stack_link__t {
      cell* stack;
      struct _stack_link__t* link;
    } stack_link__t;
    typedef stack_link__t* stack_link;
    #+end_src

*** stack

    #+begin_src c
    typedef struct {
      char* name;
      cell pointer;
      cell* stack;
      stack_link link;
    } stack__t;
    typedef stack__t* stack;

    // #define STACK_BLOCK_SIZE 1024
    #define STACK_BLOCK_SIZE 1 // for test
    #+end_src

*** new_stack

    #+begin_src c
    stack new_stack(char* name) {
      stack stack = (stack__t*)malloc(sizeof(stack__t));
      stack->name = name;
      stack->pointer = 0;
      stack->stack = (cell*)malloc(sizeof(cell) * STACK_BLOCK_SIZE);
      stack->link = NULL;
      return stack;
    }
    #+end_src

*** stack_free

    #+begin_src c
    stack_free_link(stack_link link) {
      if (link == NULL) {
        return;
      }
      else {
        stack_free_link(link->link);
        free(link->stack);
        free(link);
      }
    }

    // ><><><
    // stack->name is not freed
    stack_free(stack stack) {
      stack_free_link(stack->link);
      free(stack->stack);
      free(stack);
    }
    #+end_src

*** stack_block_underflow_check

    #+begin_src c
    // can not pop
    // for stack->pointer can not decrease under 0
    stack_block_underflow_check(stack stack) {
      if (stack->pointer > 0) {
        return;
      }
      else if (stack->link != NULL) {
        free(stack->stack);
        stack->stack = stack->link->stack;
        stack_link old_link = stack->link;
        stack->link = stack->link->link;
        free(old_link);
        stack->pointer = STACK_BLOCK_SIZE;
        return;
      }
      else {
        reportf("- stack_block_underflow_check fail\n");
        reportf("  %s underflow\n", stack->name);
        p_debug();
      }
    }
    #+end_src

*** stack_block_overflow_check

    #+begin_src c
    // can not push
    // for stack->pointer can not increase over STACK_BLOCK_SIZE
    stack_block_overflow_check(stack stack) {
      if (stack->pointer < STACK_BLOCK_SIZE) {
        return;
      }
      else {
        stack_link new_link = (stack_link__t*)malloc(sizeof(stack_link__t));
        new_link->stack = stack->stack;
        new_link->link = stack->link;
        stack->link = new_link;
        stack->stack = (cell*)malloc(sizeof(cell) * STACK_BLOCK_SIZE);
        stack->pointer = 0;
      }
    }
    #+end_src

*** stack_empty_p

    #+begin_src c
    bool stack_empty_p(stack stack) {
      return
        stack->pointer == 0 &&
        stack->link == NULL;
    }
    #+end_src

*** pop

    #+begin_src c
    cell pop(stack stack) {
      stack_block_underflow_check(stack);
      stack->pointer--;
      return stack->stack[stack->pointer];
    }
    #+end_src

*** tos

    #+begin_src c
    cell tos(stack stack) {
      stack_block_underflow_check(stack);
      return stack->stack[stack->pointer - 1];
    }
    #+end_src

*** drop

    #+begin_src c
    drop(stack stack) {
      stack_block_underflow_check(stack);
      stack->pointer--;
    }
    #+end_src

*** push

    #+begin_src c
    push(stack stack, cell data) {
      stack_block_overflow_check(stack);
      stack->stack[stack->pointer] = data;
      stack->pointer++;
    }
    #+end_src

*** stack_traverse_from_top

    #+begin_src c
    stack_traverse_from_top_help
    (cell cursor,
     cell* stack,
     stack_link link,
     void fun(cell)) {
      while (cursor > 0) {
        fun(stack[cursor - 1]);
        cursor--;
      }
      if (link != NULL) {
        stack_traverse_from_top_help
          (STACK_BLOCK_SIZE,
           link->stack,
           link->link,
           fun);
      }
    }

    stack_traverse_from_top(stack stack, void fun(cell)) {
      stack_traverse_from_top_help
        (stack->pointer,
         stack->stack,
         stack->link,
         fun);
    }
    #+end_src

*** stack_traverse_from_bottom

    #+begin_src c
    stack_traverse_from_bottom_help
    (cell cursor,
     cell* stack,
     stack_link link,
     void fun(cell)) {
      if (link != NULL) {
        stack_traverse_from_bottom_help
          (STACK_BLOCK_SIZE,
           link->stack,
           link->link,
           fun);
      }
      cell i = 0;
      while (i < cursor) {
        fun(stack[i]);
        i++;
      }
    }

    stack_traverse_from_bottom(stack stack, void fun(cell)) {
      stack_traverse_from_bottom_help
        (stack->pointer,
         stack->stack,
         stack->link,
         fun);
    }
    #+end_src

* [note] input_stack & output_stack

  - input_stack  push from high address to low address
    pop  -- read
    push -- unread

  - output_stack push from low address to high address
    push -- write
    pop  -- unwrite

* input_stack

*** [note]

    - free input_stack will not close the file.

*** input_stack_type

    #+begin_src c
    typedef enum {
      INPUT_STACK_REGULAR_FILE,
      INPUT_STACK_STRING,
      INPUT_STACK_TERMINAL,
    } input_stack_type;
    #+end_src

*** input_stack_link

    #+begin_src c
    typedef struct _input_stack_link__t {
      byte* stack;
      cell end_pointer;
      struct _input_stack_link__t* link;
    } input_stack_link__t;
    typedef input_stack_link__t* input_stack_link;
    #+end_src

*** input_stack

    #+begin_src c
    typedef struct {
      cell pointer;
      cell end_pointer;
      byte* stack;
      input_stack_link link;
      input_stack_type type;
      union {
        int   file;
        char* string;
        // int   terminal;
      };
      cell string_pointer;
    } input_stack__t;
    typedef input_stack__t* input_stack;

    // #define INPUT_STACK_BLOCK_SIZE (4 * 1024)
    #define INPUT_STACK_BLOCK_SIZE 1 // for test
    #+end_src

*** input_stack_new

    #+begin_src c
    input_stack input_stack_new(input_stack_type input_stack_type) {
      input_stack input_stack =
        (input_stack__t*)malloc(sizeof(input_stack__t));
      input_stack->pointer = INPUT_STACK_BLOCK_SIZE;
      input_stack->end_pointer = INPUT_STACK_BLOCK_SIZE;
      input_stack->stack = (byte*)malloc(INPUT_STACK_BLOCK_SIZE);
      input_stack->link = NULL;
      input_stack->type = input_stack_type;
      return input_stack;
    }
    #+end_src

*** input_stack_file

    #+begin_src c
    // readable check before call input_stack_file
    input_stack input_stack_file(int file) {
      input_stack input_stack = input_stack_new(INPUT_STACK_REGULAR_FILE);
      input_stack->file = file;
      return input_stack;
    }
    #+end_src

*** input_stack_string

    #+begin_src c
    input_stack input_stack_string(char* string) {
      input_stack input_stack = input_stack_new(INPUT_STACK_STRING);
      input_stack->string = string;
      input_stack->string_pointer = 0;
      return input_stack;
    }
    #+end_src

*** input_stack_terminal

    #+begin_src c
    input_stack input_stack_terminal() {
      input_stack input_stack = input_stack_new(INPUT_STACK_TERMINAL);
      return input_stack;
    }
    #+end_src

*** input_stack_free

    #+begin_src c
    input_stack_free_link(input_stack_link link) {
      if (link == NULL) {
        return;
      }
      else {
        input_stack_free_link(link->link);
        free(link->stack);
        free(link);
      }
    }

    input_stack_free(input_stack input_stack) {
      input_stack_free_link(input_stack->link);
      free(input_stack->stack);
      free(input_stack);
    }
    #+end_src

*** input_stack_block_underflow_check

    #+begin_src c
    // can not pop
    // for input_stack->pointer can not increase over input_stack->end_pointer
    input_stack_block_underflow_check(input_stack input_stack) {
      if (input_stack->pointer < input_stack->end_pointer) {
        return;
      }

      else if (input_stack->link != NULL) {
        free(input_stack->stack);
        input_stack->stack = input_stack->link->stack;
        input_stack->end_pointer = input_stack->link->end_pointer;
        input_stack_link old_link = input_stack->link;
        input_stack->link = input_stack->link->link;
        free(old_link);
        input_stack->pointer = 0;
        return;
      }

      else if (input_stack->type == INPUT_STACK_REGULAR_FILE) {
        ssize_t real_bytes = read(input_stack->file,
                                  input_stack->stack,
                                  INPUT_STACK_BLOCK_SIZE);
        if (real_bytes == 0) {
          reportf("- input_stack_block_underflow_check fail\n");
          reportf("  input_stack underflow\n");
          reportf("  meet end-of-file when reading a regular_file\n");
          reportf("  file descriptor : %ld\n", input_stack->file);
          p_debug();
        }
        else {
          input_stack->pointer = 0;
          input_stack->end_pointer = real_bytes;
          return;
        }
      }

      else if (input_stack->type == INPUT_STACK_STRING) {
        byte byte = input_stack->string[input_stack->string_pointer];
        if (byte == '\0') {
          reportf("- input_stack_block_underflow_check fail\n");
          reportf("  input_stack underflow\n");
          reportf("  meet end-of-string when reading a string\n");
          p_debug();
        }
        input_stack->string_pointer++;
        input_stack->end_pointer = INPUT_STACK_BLOCK_SIZE;
        input_stack->pointer = INPUT_STACK_BLOCK_SIZE - 1;
        input_stack->stack[input_stack->pointer] = byte;
        return;
      }

      else if (input_stack->type == INPUT_STACK_TERMINAL) {
        ssize_t real_bytes = read(STDIN_FILENO,
                                  input_stack->stack,
                                  INPUT_STACK_BLOCK_SIZE);
        if (real_bytes == 0) {
          reportf("- input_stack_block_underflow_check fail\n");
          reportf("  input_stack underflow\n");
          reportf("  meet end-of-file when reading from terminal\n");
          p_debug();
        }
        else {
          input_stack->pointer = 0;
          input_stack->end_pointer = real_bytes;
          return;
        }
      }

      else {
        reportf("- input_stack_block_underflow_check fail\n");
        reportf("  meet unknow stack type\n");
        reportf("  stack type number : %ld\n", input_stack->type);
        p_debug();
      }
    }
    #+end_src

*** input_stack_block_overflow_check

    #+begin_src c
    // can not push
    // for input_stack->pointer can not decrease under 0
    input_stack_block_overflow_check(input_stack input_stack) {
      if (input_stack->pointer > 0) {
        return;
      }
      else {
        input_stack_link new_link =
          (input_stack_link__t*)malloc(sizeof(input_stack_link__t));
        new_link->stack = input_stack->stack;
        new_link->link = input_stack->link;
        new_link->end_pointer = input_stack->end_pointer;
        input_stack->link = new_link;
        input_stack->stack = (byte*)malloc(INPUT_STACK_BLOCK_SIZE);
        input_stack->pointer = INPUT_STACK_BLOCK_SIZE;
        input_stack->end_pointer = INPUT_STACK_BLOCK_SIZE;
      }
    }
    #+end_src

*** input_stack_empty_p

    - note the semantic of 'input_stack_empty_p'.

      when one asks 'input_stack_empty_p',
      there is already one byte readed into the input_stack.

    #+begin_src c
    bool input_stack_empty_p(input_stack input_stack) {
      if (input_stack->pointer != input_stack->end_pointer ||
          input_stack->link != NULL) {
        return false;
      }
      if (input_stack->type == INPUT_STACK_REGULAR_FILE) {
        ssize_t real_bytes = read(input_stack->file,
                                  input_stack->stack,
                                  INPUT_STACK_BLOCK_SIZE);
        if (real_bytes == 0) {
          return true;
        }
        else {
          input_stack->pointer = 0;
          input_stack->end_pointer = real_bytes;
          return false;
        }
      }
      else if (input_stack->type == INPUT_STACK_STRING) {
        return input_stack->string[input_stack->string_pointer] == '\0';
      }
      else if (input_stack->type == INPUT_STACK_TERMINAL) {
        ssize_t real_bytes = read(STDIN_FILENO,
                                  input_stack->stack,
                                  INPUT_STACK_BLOCK_SIZE);
        if (real_bytes == 0) {
          return true;
        }
        else {
          input_stack->pointer = 0;
          input_stack->end_pointer = real_bytes;
          return false;
        }
      }
      else {
        reportf("- input_stack_empty_p meet unknow stack type\n");
        reportf("  stack type number : %ld\n", input_stack->type);
        p_debug();
      }
    }
    #+end_src

*** input_stack_pop

    #+begin_src c
    byte input_stack_pop(input_stack input_stack) {
      input_stack_block_underflow_check(input_stack);
      byte byte = input_stack->stack[input_stack->pointer];
      input_stack->pointer++;
      return byte;
    }
    #+end_src

*** input_stack_tos

    #+begin_src c
    byte input_stack_tos(input_stack input_stack) {
      input_stack_block_underflow_check(input_stack);
      byte byte = input_stack->stack[input_stack->pointer];
      return byte;
    }
    #+end_src

*** input_stack_drop

    #+begin_src c
    input_stack_drop(input_stack input_stack) {
      input_stack_block_underflow_check(input_stack);
      input_stack->pointer++;
    }
    #+end_src

*** input_stack_push

    #+begin_src c
    input_stack_push(input_stack input_stack, byte byte) {
      input_stack_block_overflow_check(input_stack);
      input_stack->pointer--;
      input_stack->stack[input_stack->pointer] = byte;
    }
    #+end_src

* output_stack

*** [note]

    - I will not seek the real file during pop and push.
      and no undo for the terminal.

    - output to
      1. file     -- the aim is to flush bytes to file
      2. string   -- the aim is to collect bytes to string
      3. terminal -- byte are directly printed to the terminal

    - flush to file or collect to string
      will not free the output_stack.

    - free output_stack will not close the file.

*** output_stack_type

    #+begin_src c
    typedef enum {
      OUTPUT_STACK_REGULAR_FILE,
      OUTPUT_STACK_STRING,
      OUTPUT_STACK_TERMINAL,
    } output_stack_type;
    #+end_src

*** output_stack_link

    #+begin_src c
    typedef struct _output_stack_link__t {
      byte* stack;
      struct _output_stack_link__t* link;
    } output_stack_link__t;
    typedef output_stack_link__t* output_stack_link;
    #+end_src

*** output_stack

    #+begin_src c
    typedef struct {
      cell pointer;
      byte* stack;
      output_stack_link link;
      output_stack_type type;
      union {
        int   file; // with cache
        // char* string;
        //   generate string
        //   instead of output to pre-allocated buffer
        // int   terminal; // no cache
      };
      cell string_pointer;
    } output_stack__t;
    typedef output_stack__t* output_stack;

    // #define OUTPUT_STACK_BLOCK_SIZE (4 * 1024)
    #define OUTPUT_STACK_BLOCK_SIZE 1 // for test
    #+end_src

*** output_stack_new

    #+begin_src c
    output_stack output_stack_new(output_stack_type output_stack_type) {
      output_stack output_stack =
        (output_stack__t*)malloc(sizeof(output_stack__t));
      output_stack->pointer = 0;
      output_stack->stack = (byte*)malloc(OUTPUT_STACK_BLOCK_SIZE);
      output_stack->link = NULL;
      output_stack->type = output_stack_type;
      return output_stack;
    }
    #+end_src

*** output_stack_file

    #+begin_src c
    // writable check before call output_stack_file
    output_stack output_stack_file(int file) {
      output_stack output_stack = output_stack_new(OUTPUT_STACK_REGULAR_FILE);
      output_stack->file = file;
      return output_stack;
    }
    #+end_src

*** output_stack_string

    #+begin_src c
    output_stack output_stack_string() {
      output_stack output_stack = output_stack_new(OUTPUT_STACK_STRING);
      return output_stack;
    }
    #+end_src

*** output_stack_terminal

    #+begin_src c
    output_stack output_stack_terminal() {
      output_stack output_stack = output_stack_new(OUTPUT_STACK_TERMINAL);
      return output_stack;
    }
    #+end_src

*** output_stack_free

    #+begin_src c
    output_stack_free_link(output_stack_link link) {
      if (link == NULL) {
        return;
      }
      else {
        output_stack_free_link(link->link);
        free(link->stack);
        free(link);
      }
    }

    output_stack_free(output_stack output_stack) {
      output_stack_free_link(output_stack->link);
      free(output_stack->stack);
      free(output_stack);
    }
    #+end_src

*** output_stack_file_flush

    #+begin_src c
    output_stack_file_flush_link(int file, output_stack_link link) {
      if (link == NULL) {
        return;
      }
      else {
        output_stack_file_flush_link(file, link->link);
        ssize_t real_bytes = write(file,
                                   link->stack,
                                   OUTPUT_STACK_BLOCK_SIZE);
        if (real_bytes != OUTPUT_STACK_BLOCK_SIZE) {
          reportf("- output_stack_file_flush_link fail\n");
          reportf("  file descriptor : %ld\n", file);
          perror("  write error : ");
          p_debug();
        }
      }
    }

    output_stack_file_flush(output_stack output_stack) {
      output_stack_file_flush_link(output_stack->file,
                                   output_stack->link);
      ssize_t real_bytes = write(output_stack->file,
                                 output_stack->stack,
                                 output_stack->pointer);
      if (real_bytes != output_stack->pointer) {
        reportf("- output_stack_file_flush fail\n");
        reportf("  file descriptor : %ld\n", output_stack->file);
        perror("  write error : ");
        p_debug();
      }
      else {
        output_stack_free_link(output_stack->link);
        output_stack->link = NULL;
        output_stack->pointer = 0;
      }
    }
    #+end_src

*** output_stack_string_collect

    #+begin_src c
    cell output_stack_string_length_link(cell sum, output_stack_link link) {
      if (link == NULL) {
        return sum;
      }
      else {
        return
          OUTPUT_STACK_BLOCK_SIZE +
          output_stack_string_length_link(sum, link->link);
      }
    }

    cell output_stack_string_length(output_stack output_stack) {
      cell sum = strlen(output_stack->stack);
      return output_stack_string_length_link(sum, output_stack->link);
    }


    byte* output_stack_string_collect_link(byte* buffer, output_stack_link link) {
      if (link == NULL) {
        return buffer;
      }
      else {
        buffer = output_stack_string_collect_link(buffer, link->link);
        memcpy(buffer, link->stack, OUTPUT_STACK_BLOCK_SIZE);
        return buffer + OUTPUT_STACK_BLOCK_SIZE;
      }
    }

    char* output_stack_string_collect(output_stack output_stack) {
      byte* string = (byte*)malloc(1 + output_stack_string_length(output_stack));
      byte* buffer = string;
      buffer = output_stack_string_collect_link(buffer, output_stack->link);
      memcpy(buffer, output_stack->stack, output_stack->pointer);
      buffer[output_stack->pointer] = '\0';
      return string;
    }
    #+end_src

*** output_stack_block_underflow_check

    #+begin_src c
    // can not pop
    // for output_stack->pointer can not decrease under 0
    output_stack_block_underflow_check(output_stack output_stack) {
      if (output_stack->pointer > 0) {
        return;
      }

      else if (output_stack->link != NULL) {
        free(output_stack->stack);
        output_stack->stack = output_stack->link->stack;
        output_stack_link old_link = output_stack->link;
        output_stack->link = output_stack->link->link;
        free(old_link);
        output_stack->pointer = OUTPUT_STACK_BLOCK_SIZE;
        return;
      }

      else if (output_stack->type == OUTPUT_STACK_REGULAR_FILE) {
        reportf("- output_stack_block_underflow_check fail\n");
        reportf("  output_stack underflow\n");
        reportf("  when writing a regular_file\n");
        reportf("  file descriptor : %ld\n", output_stack->file);
        p_debug();
      }

      else if (output_stack->type == OUTPUT_STACK_STRING) {
        reportf("- output_stack_block_underflow_check fail\n");
        reportf("  output_stack underflow\n");
        reportf("  when writing a string\n");
        p_debug();
      }

      else if (output_stack->type == OUTPUT_STACK_TERMINAL) {
        reportf("- output_stack_block_underflow_check fail\n");
        reportf("  output_stack underflow\n");
        reportf("  when writing to terminal\n");
        p_debug();
      }

      else {
        reportf("- output_stack_block_underflow_check fail\n");
        reportf("  meet unknow stack type\n");
        reportf("  stack type number : %ld\n", output_stack->type);
        p_debug();
      }
    }
    #+end_src

*** output_stack_block_overflow_check

    #+begin_src c
    // can not push
    // for output_stack->pointer can not increase over OUTPUT_STACK_BLOCK_SIZE
    output_stack_block_overflow_check(output_stack output_stack) {
      if (output_stack->pointer < OUTPUT_STACK_BLOCK_SIZE) {
        return;
      }
      else {
        output_stack_link new_link =
          (output_stack_link__t*)malloc(sizeof(output_stack_link__t));
        new_link->stack = output_stack->stack;
        new_link->link = output_stack->link;
        output_stack->link = new_link;
        output_stack->stack = (byte*)malloc(OUTPUT_STACK_BLOCK_SIZE);
        output_stack->pointer = 0;
      }
    }
    #+end_src

*** output_stack_empty_p

    #+begin_src c
    bool output_stack_empty_p(output_stack output_stack) {
      if (output_stack->pointer != 0 ||
          output_stack->link != NULL) {
        return false;
      }
      if (output_stack->type == OUTPUT_STACK_REGULAR_FILE) {
        return true;
      }
      else if (output_stack->type == OUTPUT_STACK_STRING) {
        return true;
      }
      else if (output_stack->type == OUTPUT_STACK_TERMINAL) {
        return true;
      }
      else {
        reportf("- output_stack_empty_p meet unknow stack type\n");
        reportf("  stack type number : %ld\n", output_stack->type);
        p_debug();
      }
    }
    #+end_src

*** output_stack_pop

    #+begin_src c
    byte output_stack_pop(output_stack output_stack) {
      output_stack_block_underflow_check(output_stack);
      output_stack->pointer--;
      return output_stack->stack[output_stack->pointer];
    }
    #+end_src

*** output_stack_tos

    #+begin_src c
    byte output_stack_tos(output_stack output_stack) {
      output_stack_block_underflow_check(output_stack);
      return output_stack->stack[output_stack->pointer - 1];
    }
    #+end_src

*** output_stack_drop

    #+begin_src c
    output_stack_drop(output_stack output_stack) {
      output_stack_block_underflow_check(output_stack);
      output_stack->pointer--;
    }
    #+end_src

*** output_stack_push

    #+begin_src c
    output_stack_push(output_stack output_stack, byte b) {
      if (output_stack->type == OUTPUT_STACK_TERMINAL) {
        byte buffer[1];
        buffer[0] = b;
        ssize_t real_bytes = write(STDOUT_FILENO, buffer, 1);
        if (real_bytes != 1) {
          reportf("- output_stack_push fail\n");
          perror("  write error : ");
          p_debug();
        }
      }
      else {
        output_stack_block_overflow_check(output_stack);
        output_stack->stack[output_stack->pointer] = b;
        output_stack->pointer++;
      }
    }
    #+end_src

* compiling_stack & here

*** compiling_stack

    - to redirect compiling location

    #+begin_src c
    stack compiling_stack; // of jojo

    p_compiling_stack_inc() {
      jo* jojo = pop(compiling_stack);
      push(compiling_stack, jojo + 1);
    }
    #+end_src

*** here

    #+begin_src c
    here(cell n) {
      jo* jojo = pop(compiling_stack);
      jojo[0] = n;
      push(compiling_stack, jojo + 1);
    }
    #+end_src

* data_stack & return_stack

*** data_stack

    #+begin_src c
    typedef cell data_stack_t[1024 * 4];

    data_stack_t data_stack;
    cell data_stack_base = 64;
    cell data_stack_pointer = 64;

    data_stack_push(cell value) {
      data_stack[data_stack_pointer] = value;
      data_stack_pointer++;
    }

    cell data_stack_pop() {
      data_stack_pointer--;
      return data_stack[data_stack_pointer];
    }

    cell data_stack_tos() {
      return data_stack[data_stack_pointer - 1];
    }

    bool data_stack_empty_p() {
      return data_stack_base == data_stack_pointer;
    }
    #+end_src

*** local

    #+begin_src c
    typedef struct {
      jo name;
      cell local_tag;
      cell local_data;
    } local_point;

    local_point local_record[4 * 1024];
    cell current_local_pointer = 0;
    #+end_src

*** return_stack

    #+begin_src c
    typedef struct {
      jo* jojo;
      cell local_pointer;
    } return_point;

    typedef return_point return_stack_t[1024 * 4];

    return_stack_t return_stack;
    cell return_stack_base = 64;
    cell return_stack_pointer = 64;

    return_stack_push(return_point value) {
      return_stack[return_stack_pointer] = value;
      return_stack_pointer++;
    }

    return_point return_stack_pop() {
      return_stack_pointer--;
      return return_stack[return_stack_pointer];
    }

    return_point return_stack_tos() {
      return return_stack[return_stack_pointer - 1];
    }

    bool return_stack_empty_p() {
      return return_stack_base == return_stack_pointer;
    }

    return_stack_make_point(jo* jojo, cell local_pointer) {
      return_point rp = {.jojo = jojo, .local_pointer = local_pointer};
      return_stack[return_stack_pointer] = rp;
      return_stack_pointer++;
    }

    return_stack_new_point(jo* jojo) {
      return_stack_make_point(jojo, current_local_pointer);
    }

    return_stack_inc() {
      return_point rp = return_stack_pop();
      return_point rp1 = {.jojo = rp.jojo + 1,
                          .local_pointer = rp.local_pointer};
      return_stack_push(rp1);
    }
    #+end_src

* *name*

*** name_record

    #+begin_src c
    jo name_record[16 * 1024];
    cell name_record_counter = 0;
    #+end_src

*** p_name_record

    #+begin_src c
    p_name_record() {
      data_stack_push(name_record);
    }
    #+end_src

*** binding_filter_stack

***** binding_filter_stack

      #+begin_src c
      stack binding_filter_stack; // of jo
      #+end_src

***** p_binding_filter_stack_push

      #+begin_src c
      p_binding_filter_stack_push() {
        push(binding_filter_stack, data_stack_pop());
      }
      #+end_src

***** p_binding_filter_stack_pop

      #+begin_src c
      p_binding_filter_stack_pop() {
        data_stack_push(pop(binding_filter_stack));
      }
      #+end_src

***** run_binding_filter

      #+begin_src c
      jo_apply_now(jo jo);

      run_binding_filter() {
        // [name] -> [name]
        stack_traverse_from_bottom(binding_filter_stack, jo_apply_now);
      }
      #+end_src

*** name_can_bind_p

    #+begin_src c
    bool name_can_bind_p(jo name) {
      if (name->tag == JO_DECLARED) {
        return true;
      }
      else if (used_jo_p(name)) {
        return false;
      }
      else {
        return true;
      }
    }
    #+end_src

*** p_bind_name

    #+begin_src c
    p_bind_name() {
      // [data tag name] -> {set-jotable}
      run_binding_filter();

      jo name = data_stack_pop();
      jo tag = data_stack_pop();
      cell data = data_stack_pop();

      if (!name_can_bind_p(name)) {
        reportf("- p_bind_name can not rebind\n");
        reportf("  name : %s\n", jo2str(name));
        reportf("  tag : %s\n", jo2str(tag));
        reportf("  data : %ld\n", data);
        reportf("  it has been bound as a %s\n", jo2str(name->tag));
        return;
      }

      name_record[name_record_counter] = name;
      name_record_counter++;
      name_record[name_record_counter] = 0;

      name->tag = tag;
      name->value = data;
    }
    #+end_src

*** p_rebind_name

    #+begin_src c
    p_rebind_name() {
      // [data tag name] -> {set-jotable}
      run_binding_filter();

      jo name = data_stack_pop();
      jo tag = data_stack_pop();
      cell data = data_stack_pop();

      if (!used_jo_p(name)) {
        name_record[name_record_counter] = name;
        name_record_counter++;
        name_record[name_record_counter] = 0;
      }

      name->tag = tag;
      name->value = data;
    }
    #+end_src

*** define_prim

    #+begin_src c
    define_prim(char* str, primitive fun) {
      jo name = str2jo(str);
      data_stack_push(fun);
      data_stack_push(TAG_PRIM);
      data_stack_push(name);
      p_bind_name();
    }
    #+end_src

*** define_primkey

    #+begin_src c
    define_primkey(char* str, primitive fun) {
      jo name = str2jo(str);
      data_stack_push(fun);
      data_stack_push(TAG_PRIM_KEYWORD);
      data_stack_push(name);
      p_bind_name();
    }
    #+end_src

*** expose_name

    #+begin_src c
    expose_name() {
      define_prim("bind-name", p_bind_name);
      define_prim("rebind-name", p_rebind_name);

      define_prim("name-record", p_name_record);

      define_prim("binding-filter-stack-push", p_binding_filter_stack_push);
      define_prim("binding-filter-stack-pop", p_binding_filter_stack_pop);
    }
    #+end_src

* *apply* & eval

*** [note]

    - be careful when calling jo_apply in primitive,
      because after return_stack_push a jojo,
      one need to exit current primitive to run the jojo.

      if wished follow a 'eval();' after jo_apply
      to return to the primitive function.

    - keyword_stack and alias_record
      form a hook for read_jo.

*** keyword_stack

    #+begin_src c
    stack keyword_stack; // of alias_pointer
    #+end_src

*** alias

    #+begin_src c
    typedef struct {
      jo nick;
      jo name;
    } alias_point;

    alias_point alias_record[1024];
    cell current_alias_pointer = 0;
    #+end_src

*** jo_apply

    #+begin_src c
    eval();
    p_debug();

    jo_apply(jo jo) {
      if (!used_jo_p(jo)) {
        reportf("- jo_apply meet undefined jo : %s\n", jo2str(jo));
        p_debug();
        return;
      }

      cell tag = jo->tag;

      if (tag == TAG_PRIM) {
        primitive primitive = jo->value;
        primitive();
      }
      else if (tag == TAG_JOJO) {
        cell jojo = jo->value;
        return_stack_new_point(jojo);
      }

      else if (tag == TAG_PRIM_KEYWORD) {
        push(keyword_stack, current_alias_pointer);
        primitive primitive = jo->value;
        primitive();
        current_alias_pointer = pop(keyword_stack);
      }
      else if (tag == TAG_KEYWORD) {
        // keywords are always evaled
        push(keyword_stack, current_alias_pointer);
        cell jojo = jo->value;
        return_stack_new_point(jojo);
        eval();
        current_alias_pointer = pop(keyword_stack);
      }

      else if (tag == TAG_DATA) {
        cell cell = jo->value;
        data_stack_push(cell);
      }
      else {
        cell cell = jo->value;
        data_stack_push(cell);
        data_stack_push(tag);
      }
    }
    #+end_src

*** jo_apply_now

    #+begin_src c
    jo_apply_now(jo jo) {
      cell tag = jo->tag;
      if (tag == TAG_JOJO) {
        cell jojo = jo->value;
        return_stack_new_point(jojo);
        eval();
        return;
      }
      else {
        jo_apply(jo);
        return;
      }
    }
    #+end_src

*** jo_apply_with_local_pointer

    #+begin_src c
    jo_apply_with_local_pointer(jo jo, cell local_pointer) {
      cell tag = jo->tag;
      if (tag == TAG_JOJO) {
        cell jojo = jo->value;
        return_stack_make_point(jojo, local_pointer);
        return;
      }
      else {
        jo_apply(jo);
        return;
      }
    }
    #+end_src

*** eval

    #+begin_src c
    bool step_flag = false;

    stepper();
    exit_stepper();

    eval() {
      cell base = return_stack_pointer;
      while (return_stack_pointer >= base) {
        return_point rp = return_stack_tos();
        return_stack_inc();
        jo* jojo = rp.jojo;
        jo jo = jojo[0];
        jo_apply(jo);
        if (step_flag == true) {
          stepper();
        }
      }
      if (step_flag == true) {
        reportf("- the stepped jojo is finished\n");
        exit_stepper();
      }
    }
    #+end_src

*** p_apply

    #+begin_src c
    p_apply() {
      return_stack_new_point(data_stack_pop());
    }
    #+end_src

*** p_apply_with_local_pointer

    #+begin_src c
    p_apply_with_local_pointer() {
      // [local_pointer jojo] -> [*]
      jo* jojo = data_stack_pop();
      cell local_pointer = data_stack_pop();
      return_stack_make_point(jojo, local_pointer);
    }
    #+end_src

*** p_jo_apply

    #+begin_src c
    p_jo_apply() {
      jo_apply(data_stack_pop());
    }
    #+end_src

*** p_jo_apply_with_local_pointer

    #+begin_src c
    p_jo_apply_with_local_pointer() {
      jo jo = data_stack_pop();
      cell local_pointer = data_stack_pop();
      jo_apply_with_local_pointer(jo, local_pointer);
    }
    #+end_src

*** expose_apply

    #+begin_src c
    expose_apply() {
      define_prim("apply", p_apply);
      define_prim("apply-with-local-pointer", p_apply_with_local_pointer);

      define_prim("jo/apply", p_jo_apply);
      define_prim("jo/apply-with-local-pointer", p_jo_apply_with_local_pointer);
    }
    #+end_src

* *stack_operation*

*** p_drop

    #+begin_src c
    p_drop() {
      data_stack_pop();
    }
    #+end_src

*** p_2drop

    #+begin_src c
    p_2drop() {
      data_stack_pop();
      data_stack_pop();
    }
    #+end_src

*** p_dup

    #+begin_src c
    p_dup() {
      // a a -> a
      cell a = data_stack_pop();
      data_stack_push(a);
      data_stack_push(a);
    }
    #+end_src

*** p_2dup

    #+begin_src c
    p_2dup() {
      // b a -> b a b a
      cell a = data_stack_pop();
      cell b = data_stack_pop();
      data_stack_push(b);
      data_stack_push(a);
      data_stack_push(b);
      data_stack_push(a);
    }
    #+end_src

*** p_over

    #+begin_src c
    p_over() {
      // b a -> b a b
      cell a = data_stack_pop();
      cell b = data_stack_pop();
      data_stack_push(b);
      data_stack_push(a);
      data_stack_push(b);
    }
    #+end_src

*** p_2over

    #+begin_src c
    p_2over() {
      // d c  b a -> d c  b a  d c
      cell a = data_stack_pop();
      cell b = data_stack_pop();
      cell c = data_stack_pop();
      cell d = data_stack_pop();
      data_stack_push(d);
      data_stack_push(c);
      data_stack_push(b);
      data_stack_push(a);
      data_stack_push(d);
      data_stack_push(c);
    }
    #+end_src

*** p_tuck

    #+begin_src c
    p_tuck() {
      // b a -> a b a
      cell a = data_stack_pop();
      cell b = data_stack_pop();
      data_stack_push(a);
      data_stack_push(b);
      data_stack_push(a);
    }
    #+end_src

*** p_2tuck

    #+begin_src c
    p_2tuck() {
      // d c  b a -> b a  d c  b a
      cell a = data_stack_pop();
      cell b = data_stack_pop();
      cell c = data_stack_pop();
      cell d = data_stack_pop();
      data_stack_push(b);
      data_stack_push(a);
      data_stack_push(d);
      data_stack_push(c);
      data_stack_push(b);
      data_stack_push(a);
    }
    #+end_src

*** p_swap

    #+begin_src c
    p_swap() {
      // b a -> a b
      cell a = data_stack_pop();
      cell b = data_stack_pop();
      data_stack_push(a);
      data_stack_push(b);
    }
    #+end_src

*** p_2swap

    #+begin_src c
    p_2swap() {
      // d c  b a -> b a  d c
      cell a = data_stack_pop();
      cell b = data_stack_pop();
      cell c = data_stack_pop();
      cell d = data_stack_pop();
      data_stack_push(b);
      data_stack_push(a);
      data_stack_push(d);
      data_stack_push(c);
    }
    #+end_src

*** p_print_data_stack

    #+begin_src c
    p_print_data_stack() {
      // {terminal-output}
      if (data_stack_pointer < data_stack_base) {
        reportf("  * %ld *  ", (data_stack_pointer - data_stack_base));
        reportf("-- below the stack --\n");
      }
      else {
        reportf("  * %ld *  ", (data_stack_pointer - data_stack_base));
        reportf("-- ");
        cell i = data_stack_base;
        while (i < data_stack_pointer) {
          reportf("%ld ", data_stack[i]);
          i++;
        }
        reportf("--\n");
      }
    }
    #+end_src

*** p_stack_base

    #+begin_src c
    p_stack_base() {
      data_stack_push(data_stack + data_stack_base);
    }
    #+end_src

*** p_stack_pointer

    #+begin_src c
    p_stack_pointer() {
      data_stack_push(data_stack + data_stack_pointer);
    }
    #+end_src

*** expose_stack_operation

    #+begin_src c
    expose_stack_operation() {
      define_prim("drop", p_drop);
      define_prim("2drop", p_2drop);
      define_prim("dup", p_dup);
      define_prim("2dup", p_2dup);
      define_prim("over", p_over);
      define_prim("2over", p_2over);
      define_prim("tuck", p_tuck);
      define_prim("2tuck", p_2tuck);
      define_prim("swap", p_swap);
      define_prim("2swap", p_2swap);
      define_prim("print-data-stack", p_print_data_stack);
      define_prim("stack-pointer", p_stack_pointer);
      define_prim("stack-base", p_stack_base);
    }
    #+end_src

* *ending*

*** p_end

    #+begin_src c
    p_end() {
      return_point rp = return_stack_pop();
      current_local_pointer = rp.local_pointer;
    }
    #+end_src

*** p_bye

    #+begin_src c
    p_bye() {
      reportf("bye bye ^-^/\n");
      exit(0);
    }
    #+end_src

*** expose_ending

    #+begin_src c
    expose_ending() {
      define_prim("end", p_end);
      define_prim("bye", p_bye);
    }
    #+end_src

* *bool*

*** p_true

    #+begin_src c
    p_true() {
      data_stack_push(true);
    }
    #+end_src

*** p_false

    #+begin_src c
    p_false() {
      data_stack_push(false);
    }
    #+end_src

*** p_not

    #+begin_src c
    p_not() {
      // bool -> bool
      cell a = data_stack_pop();
      data_stack_push(!a);
    }
    #+end_src

*** p_and

    #+begin_src c
    p_and() {
      // bool bool -> bool
      cell a = data_stack_pop();
      cell b = data_stack_pop();
      data_stack_push(a&&b);
    }
    #+end_src

*** p_or

    #+begin_src c
    p_or() {
      // bool bool -> bool
      cell a = data_stack_pop();
      cell b = data_stack_pop();
      data_stack_push(a||b);
    }
    #+end_src

*** expose_bool

    #+begin_src c
    expose_bool() {
      define_prim("true", p_true);
      define_prim("false", p_false);
      define_prim("not", p_not);
      define_prim("and", p_and);
      define_prim("or", p_or);
    }
    #+end_src

* *int*

*** p_inc

    #+begin_src c
    p_inc() {
      cell a = data_stack_pop();
      data_stack_push(a + 1);
    }
    #+end_src

*** p_dec

    #+begin_src c
    p_dec() {
      cell a = data_stack_pop();
      data_stack_push(a - 1);
    }
    #+end_src

*** p_neg

    #+begin_src c
    p_neg() {
      cell a = data_stack_pop();
      data_stack_push(- a);
    }
    #+end_src

*** p_add

    #+begin_src c
    p_add() {
      cell b = data_stack_pop();
      cell a = data_stack_pop();
      data_stack_push(a + b);
    }
    #+end_src

*** p_sub

    #+begin_src c
    p_sub() {
      cell b = data_stack_pop();
      cell a = data_stack_pop();
      data_stack_push(a - b);
    }
    #+end_src

*** p_mul

    #+begin_src c
    p_mul() {
      cell b = data_stack_pop();
      cell a = data_stack_pop();
      data_stack_push(a * b);
    }
    #+end_src

*** p_div

    #+begin_src c
    p_div() {
      cell b = data_stack_pop();
      cell a = data_stack_pop();
      data_stack_push(a / b);
    }
    #+end_src

*** p_mod

    #+begin_src c
    p_mod() {
      cell b = data_stack_pop();
      cell a = data_stack_pop();
      data_stack_push(a % b);
    }
    #+end_src

*** p_eq_p

    #+begin_src c
    p_eq_p() {
      cell b = data_stack_pop();
      cell a = data_stack_pop();
      data_stack_push(a == b);
    }
    #+end_src

*** p_gt_p

    #+begin_src c
    p_gt_p() {
      cell b = data_stack_pop();
      cell a = data_stack_pop();
      data_stack_push(a > b);
    }
    #+end_src

*** p_lt_p

    #+begin_src c
    p_lt_p() {
      cell b = data_stack_pop();
      cell a = data_stack_pop();
      data_stack_push(a < b);
    }
    #+end_src

*** p_gteq_p

    #+begin_src c
    p_gteq_p() {
      cell b = data_stack_pop();
      cell a = data_stack_pop();
      data_stack_push(a >= b);
    }
    #+end_src

*** p_lteq_p

    #+begin_src c
    p_lteq_p() {
      cell b = data_stack_pop();
      cell a = data_stack_pop();
      data_stack_push(a <= b);
    }
    #+end_src

*** i_int

    #+begin_src c
    i_int() {
      // [] -> [cell] {return_stack}
      return_point rp = return_stack_tos();
      return_stack_inc();
      jo* jojo = rp.jojo;
      jo jo = jojo[0];
      data_stack_push(jo);
    }
    #+end_src

*** k_int

    #+begin_src c
    jo read_raw_jo();

    k_int() {
      // (int ...)
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_KET) {
          break;
        }
        else {
          here(JO_INS_INT);
          here(string_to_int(jo2str(s)));
        }
      }
    }
    #+end_src

*** p_int_print

    #+begin_src c
    p_int_print() { printf("%ld", data_stack_pop()); }
    #+end_src

*** p_dot & p_int_dot

    #+begin_src c
    p_dot() { printf("%ld ", data_stack_pop()); }
    p_int_dot() { printf("%ld ", data_stack_pop()); }
    #+end_src

*** expose_int

    #+begin_src c
    expose_int() {
      define_prim("inc", p_inc);
      define_prim("dec", p_dec);
      define_prim("neg", p_neg);

      define_prim("add", p_add);
      define_prim("sub", p_sub);

      define_prim("mul", p_mul);
      define_prim("div", p_div);
      define_prim("mod", p_mod);

      define_prim("eq?", p_eq_p);
      define_prim("gt?", p_gt_p);
      define_prim("lt?", p_lt_p);
      define_prim("gteq?", p_gteq_p);
      define_prim("lteq?", p_lteq_p);

      define_prim("ins/int", i_int);
      define_primkey("int", k_int);

      define_prim("int/print", p_int_print);

      define_prim("dot", p_dot);
      define_prim("int/dot", p_int_dot);
    }
    #+end_src

* *memory*

*** p_allocate

    #+begin_src c
    p_allocate () {
      // size -> addr
      data_stack_push(calloc(data_stack_pop(), 1));
    }
    #+end_src

*** p_free

    #+begin_src c
    p_free () {
      // addr ->
      free(data_stack_pop());
    }
    #+end_src

*** k_address

    #+begin_src c
    k_ignore();

    k_address() {
      // (address ...)
      here(JO_INS_ADDRESS);
      jo name = read_raw_jo();
      here(&(name->value));
      k_ignore();
    }
    #+end_src

*** p_jo_as_var

    #+begin_src c
    p_jo_as_var() {
      jo jo = data_stack_pop();
      data_stack_push(&(jo->value));
    }
    #+end_src

*** p_set_cell

    #+begin_src c
    p_set_cell() {
      // cell address ->
      cell* address = data_stack_pop();
      cell value = data_stack_pop();
      address[0] = value;
    }
    #+end_src

*** p_get_cell

    #+begin_src c
    p_get_cell() {
      // address -> cell
      cell* address = data_stack_pop();
      data_stack_push(address[0]);
    }
    #+end_src

*** p_set_byte

    #+begin_src c
    p_set_byte() {
      // byte address ->
      char* address = data_stack_pop();
      cell value = data_stack_pop();
      address[0] = value;
    }
    #+end_src

*** p_get_byte

    #+begin_src c
    p_get_byte() {
      // address -> byte
      char* address = data_stack_pop();
      data_stack_push(address[0]);
    }
    #+end_src

*** expose_memory

    #+begin_src c
    expose_memory() {
      define_prim("allocate", p_allocate);
      define_prim("free", p_free);

      define_prim("ins/address", i_int);
      define_primkey("address", k_address);

      define_prim("jo-as-var", p_jo_as_var);
      define_prim("set-cell", p_set_cell);
      define_prim("get-cell", p_get_cell);
      define_prim("set-byte", p_set_byte);
      define_prim("get-byte", p_get_byte);
    }
    #+end_src

* *byte*

*** [note]

    - reading_stack and writing_stack can be :
      1. file
      2. buffer
      3. terminal

*** reading_stack

    #+begin_src c
    stack reading_stack; // of input_stack
    #+end_src

*** get_real_reading_path

    #+begin_src c
    erase_real_path_to_dir(char* path) {
      cell cursor = strlen(path);
      while (path[cursor] != '/') {
        path[cursor] = '\0';
        cursor--;
      }
      path[cursor] = '\0';
    }

    char* get_real_reading_path(char* path) {
      // caller of this function
      // should free its return value
      char* real_reading_path = malloc(PATH_MAX);
      if (path[0] == '/' ||
          ((input_stack__t*)tos(reading_stack))->type == INPUT_STACK_TERMINAL) {
        realpath(path, real_reading_path);
        return real_reading_path;
      }
      else {
        char* proc_link_path = malloc(PATH_MAX);
        sprintf(proc_link_path,
                "/proc/self/fd/%d",
                ((input_stack__t*)tos(reading_stack))->file);
        ssize_t real_bytes = readlink(proc_link_path, real_reading_path, PATH_MAX);
        if (real_bytes == -1) {
          reportf("- get_real_reading_path fail to readlink\n");
          reportf("  proc_link_path : %s\n", proc_link_path);
          perror("  readlink : ");
          free(proc_link_path);
          free(real_reading_path);
          p_debug();
          return NULL; // to fool the compiler
        }
        free(proc_link_path);
        real_reading_path[real_bytes] = '\0';
        erase_real_path_to_dir(real_reading_path);
        strcat(real_reading_path, "/");
        strcat(real_reading_path, path);
        return real_reading_path;
      }
    }
    #+end_src

*** has_byte_p

    #+begin_src c
    bool has_byte_p() {
      return !input_stack_empty_p(tos(reading_stack));
    }
    #+end_src

*** p_has_byte_p

    #+begin_src c
    p_has_byte_p() {
      data_stack_push(has_byte_p());
    }
    #+end_src

*** read_byte

    #+begin_src c
    byte read_byte() {
      return input_stack_pop(tos(reading_stack));
    }
    #+end_src

*** p_read_byte

    #+begin_src c
    p_read_byte() {
      // -> byte
      data_stack_push(read_byte());
    }
    #+end_src

*** byte_unread

    #+begin_src c
    byte_unread(byte b) {
      input_stack_push(tos(reading_stack), b);
    }
    #+end_src

*** p_byte_unread

    #+begin_src c
    p_byte_unread() {
      // byte -> {reading_stack}
      byte_unread(data_stack_pop());
    }
    #+end_src

*** p_byte_print

    #+begin_src c
    p_byte_print() {
      // byte ->
      printf("%c", data_stack_pop());
    }
    #+end_src

*** p_ignore_until_double_quote

    #+begin_src c
    p_ignore_until_double_quote() {
      while (true) {
        jo jo = read_raw_jo();
        if (jo == DOUBLE_QUOTE) {
          return;
        }
        else {
          // loop
        }
      }
    }
    #+end_src

*** k_one_byte

    #+begin_src c
    k_one_byte() {
      byte byte = read_byte();
      p_ignore_until_double_quote();
      here(JO_INS_BYTE);
      here(byte);
    }
    #+end_src

*** k_byte

    #+begin_src c
    k_byte() {
      // (byte ...)
      while (true) {
        jo jo = read_raw_jo();
        if (jo == ROUND_KET) {
          return;
        }
        else if (jo == DOUBLE_QUOTE) {
          k_one_byte();
          // loop
        }
        else {
          // loop
        }
      }
    }
    #+end_src

*** expose_byte

    #+begin_src c
    expose_byte() {
      define_prim("has-byte?", p_has_byte_p);
      define_prim("read/byte", p_read_byte);
      define_prim("byte/unread", p_byte_unread);
      define_prim("byte/print", p_byte_print);
      define_prim("ignore-until-double-quote", p_ignore_until_double_quote);

      define_prim("ins/byte", i_int);
      define_primkey("byte", k_byte);
    }
    #+end_src

* *jo*

*** p_alias_add

    #+begin_src c
    p_alias_add() {
      jo name = data_stack_pop();
      jo nick = data_stack_pop();
      alias_record[current_alias_pointer].nick = nick;
      alias_record[current_alias_pointer].name = name;
      current_alias_pointer++;
    }
    #+end_src

*** p_alias_filter

    #+begin_src c
    p_alias_filter() {
      // nick -> name
      if (stack_empty_p(keyword_stack)) {
        return;
      }
      jo nick = data_stack_pop();
      cell base = tos(keyword_stack);
      cell i = current_alias_pointer;
      while (i >= base) {
        if (alias_record[i].nick == nick) {
          data_stack_push(alias_record[i].name);
          return;
        }
        else {
          i--;
        }
      }
      data_stack_push(nick);
    }
    #+end_src

*** has_jo_p

    #+begin_src c
    bool has_jo_p() {
      byte c;
      while (true) {

        if (!has_byte_p()) {
          return false;
        }

        c = read_byte();

        if (isspace(c)) {
          // loop
        }
        else {
          byte_unread(c);
          return true;
        }
      }
    }
    #+end_src

*** p_has_jo_p

    #+begin_src c
    p_has_jo_p() {
      data_stack_push(has_jo_p());
    }
    #+end_src

*** p_read_raw_jo

    #+begin_src c
    p_read_raw_jo() {
      // {reading_stack} -> jo
      byte buf[1024];
      cell cur = 0;
      cell collecting = false;
      byte c;
      byte go = true;

      while (go) {

        if (!has_byte_p()) {
          if (!collecting) {
            reportf("- p_read_raw_jo meet end-of-file\n");
            return;
          }
          else {
            break;
          }
        }

        c = read_byte(); // reportf("- read_byte() : %c\n", c);

        if (!collecting) {
          if (isspace(c)) {
            // loop
          }
          else {
            collecting = true;
            buf[cur] = c;
            cur++;
            if (isbarcket(c)) {
              go = false;
            }
          }
        }

        else {
          if (isbarcket(c) ||
              isspace(c)) {
            byte_unread(c);
            go = false;
          }
          else {
            buf[cur] = c;
            cur++;
          }
        }
      }

      buf[cur] = 0;
      data_stack_push(str2jo(buf));
    }
    #+end_src

*** jo_filter_stack

***** jo_filter_stack

      #+begin_src c
      stack jo_filter_stack; // of jo
      #+end_src

***** p_jo_filter_stack_push

      #+begin_src c
      p_jo_filter_stack_push() {
        push(jo_filter_stack, data_stack_pop());
      }
      #+end_src

***** p_jo_filter_stack_pop

      #+begin_src c
      p_jo_filter_stack_pop() {
        data_stack_push(pop(jo_filter_stack));
      }
      #+end_src

***** run_jo_filter

      - the order is important

      #+begin_src c
      run_jo_filter() {
        stack_traverse_from_bottom(jo_filter_stack, jo_apply_now);
      }
      #+end_src

*** p_read_jo

    #+begin_src c
    p_read_jo() {
      p_read_raw_jo();
      run_jo_filter();
    }
    #+end_src

*** read_jo

    #+begin_src c
    jo read_jo() {
      p_read_jo();
      return data_stack_pop();
    }
    #+end_src

*** read_raw_jo

    #+begin_src c
    jo read_raw_jo() {
      p_read_raw_jo();
      return data_stack_pop();
    }
    #+end_src

*** cat_2_jo

    #+begin_src c
    jo cat_2_jo(jo x, jo y) {
      char str[2 * 1024];
      str[0] = 0;
      strcat(str, jo2str(x));
      strcat(str, jo2str(y));
      return str2jo(str);
    }
    #+end_src

*** cat_3_jo

    #+begin_src c
    jo cat_3_jo(jo x, jo y, jo z) {
      char str[3 * 1024];
      str[0] = 0;
      strcat(str, jo2str(x));
      strcat(str, jo2str(y));
      strcat(str, jo2str(z));
      return str2jo(str);
    }
    #+end_src

*** p_jo_append

    #+begin_src c
    p_jo_append() {
      jo jo2 = data_stack_pop();
      jo jo1 = data_stack_pop();
      data_stack_push(cat_2_jo(jo1, jo2));
    }
    #+end_src

*** p_empty_jo

    #+begin_src c
    p_empty_jo() {
      data_stack_push(EMPTY_JO);
    }
    #+end_src

*** p_jo_used_p

    #+begin_src c
    p_jo_used_p() {
      // jo -> bool
      jo jo = data_stack_pop();
      data_stack_push(used_jo_p(jo));
    }
    #+end_src

*** p_jo_to_string

    #+begin_src c
    p_jo_to_string() {
      // jo -> string
      jo jo = data_stack_pop();
      data_stack_push(jo2str(jo));
    }
    #+end_src

*** p_string_length_to_jo

    #+begin_src c
    p_string_length_to_jo() {
      // string length -> jo
      cell len = data_stack_pop();
      cell str = data_stack_pop();
      char buffer[2 * 1024];
      strncpy(buffer, str, len);
      buffer[len] = 0;
      data_stack_push(str2jo(buffer));
    }
    #+end_src

*** p_string_to_jo

    #+begin_src c
    p_string_to_jo() {
      // string -> jo
      char* str = data_stack_pop();
      data_stack_push(str2jo(str));
    }
    #+end_src

*** p_null

    #+begin_src c
    p_null() {
      data_stack_push(JO_NULL);
    }
    #+end_src

*** k_raw_jo

    #+begin_src c
    k_raw_jo() {
      // (raw-jo ...)
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_BAR) {
          jo_apply(read_jo());
        }
        else if (s == ROUND_KET) {
          break;
        }
        else {
          here(JO_INS_JO);
          here(s);
        }
      }
    }
    #+end_src

*** k_jo

    #+begin_src c
    k_jo() {
      // (jo ...)
      while (true) {
        jo s = read_jo();
        if (s == ROUND_BAR) {
          jo_apply(read_jo());
        }
        else if (s == ROUND_KET) {
          break;
        }
        else {
          here(JO_INS_JO);
          here(s);
        }
      }
    }
    #+end_src

*** p_jo_print

    #+begin_src c
    p_jo_print() {
      // jo -> {terminal-output}
      printf("%s", jo2str(data_stack_pop()));
    }
    #+end_src

*** p_jo_dot

    #+begin_src c
    p_jo_dot() {
      // jo -> {terminal-output}
      printf("%s ", jo2str(data_stack_pop()));
    }
    #+end_src

*** p_generate_jo

    #+begin_src c
    cell p_generate_jo_counter = 0;
    p_generate_jo() {
      char* s = data_stack_pop();
      char buffer [1024];
      sprintf(buffer, "%s:generated-jo#%ld", jo2str(s), p_generate_jo_counter);
      p_generate_jo_counter++;
      data_stack_push(str2jo(buffer));
    }
    #+end_src

*** p_jo_find_byte

    #+begin_src c
    p_jo_find_byte() {
      // byte jo -> [index true] or [false]
      p_jo_to_string();
      p_string_find_byte();
    }
    #+end_src

*** p_jo_right_part

    #+begin_src c
    p_jo_right_part() {
      // index jo -> jo
      jo jo = data_stack_pop();
      cell index = data_stack_pop();
      char* s = jo2str(jo);
      data_stack_push(str2jo(s + index));
    }
    #+end_src

*** p_jo_left_part

    #+begin_src c
    p_jo_left_part() {
      // index jo -> jo
      char target[1024];
      jo jo = data_stack_pop();
      cell index = data_stack_pop();
      char* source = jo2str(jo);
      cell i = 0;
      while (i < index) {
        target[i] = source[i];
        i++;
      }
      target[index] = 0;
      data_stack_push(str2jo(target));
    }
    #+end_src

*** p_jo_part

    #+begin_src c
    p_jo_part() {
      // index-begin index-end jo -> jo
      char target[1024];
      jo jo = data_stack_pop();
      cell index_end = data_stack_pop();
      cell index_begin = data_stack_pop();
      char* source = jo2str(jo);
      cell i = index_begin;
      while (i < index_end) {
        target[i] = source[i];
        i++;
      }
      target[index_end] = 0;
      data_stack_push(str2jo(target + index_begin));
    }
    #+end_src

*** expose_jo

    #+begin_src c
    expose_jo() {
      define_prim("null", p_null);

      define_prim("jo-filter-stack-push", p_jo_filter_stack_push);
      define_prim("jo-filter-stack-pop", p_jo_filter_stack_pop);

      define_prim("alias-add", p_alias_add);
      define_prim("alias-filter", p_alias_filter);

      define_prim("has-jo?", p_has_jo_p);

      define_prim("read/raw-jo", p_read_raw_jo);
      define_prim("read/jo", p_read_jo);

      define_prim("ins/jo", i_int);
      define_primkey("jo", k_jo);
      define_primkey("raw-jo", k_raw_jo);

      define_prim("jo/used?", p_jo_used_p);
      define_prim("jo/append", p_jo_append);
      define_prim("empty-jo", p_empty_jo);
      define_prim("jo->string", p_jo_to_string);
      define_prim("string->jo", p_string_to_jo);
      define_prim("string/length->jo", p_string_length_to_jo);
      define_prim("jo/print", p_jo_print);
      define_prim("jo/dot", p_jo_dot);
      define_prim("generate-jo", p_generate_jo);

      define_prim("jo/find-byte", p_jo_find_byte);
      define_prim("jo/left-part", p_jo_left_part);
      define_prim("jo/right-part", p_jo_right_part);
      define_prim("jo/part", p_jo_part);
    }
    #+end_src

* *string*

*** k_one_string

    #+begin_src c
    k_one_string() {
      // "..."
      char buffer[1024 * 1024];
      cell cursor = 0;
      while (true) {
        char c = read_byte();
        if (c == '"') {
          buffer[cursor] = 0;
          cursor++;
          break;
        }
        else {
          buffer[cursor] = c;
          cursor++;
        }
      }
      char* str = malloc(cursor);
      strcpy(str, buffer);
      here(JO_INS_STRING);
      here(str);
    }
    #+end_src

*** k_string

    #+begin_src c
    k_string() {
      // (string "...")
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_KET) {
          return;
        }
        else if (s == DOUBLE_QUOTE) {
          k_one_string();
        }
        else {
          // do nothing
        }
      }
    }
    #+end_src

*** p_string_length

    #+begin_src c
    p_string_length() {
      // string -> length
      data_stack_push(strlen(data_stack_pop()));
    }
    #+end_src

*** p_string_print

    #+begin_src c
    p_string_print() {
      // string -> {terminal-output}
      printf("%s", data_stack_pop());
    }
    #+end_src

*** p_string_dot

    #+begin_src c
    p_string_dot() {
      // string -> {terminal-output}
      printf("\"%s \"", data_stack_pop());
    }
    #+end_src

*** p_string_append_to_buffer

    #+begin_src c
    p_string_append_to_buffer() {
      // buffer string -> buffer
      char* str = data_stack_pop();
      char* buffer = data_stack_tos();
      strcat(buffer, str);
    }
    #+end_src

***** p_string_first_byte

    #+begin_src c
    p_string_first_byte() {
      char* s = data_stack_pop();
      data_stack_push(s[0]);
    }
    #+end_src

*** p_string_last_byte

    #+begin_src c
    p_string_last_byte() {
      char* s = data_stack_pop();
      cell i = 0;
      while (s[i+1] != 0) {
        i++;
      }
      data_stack_push(s[i]);
    }
    #+end_src

*** p_string_member_p

    #+begin_src c
    p_string_member_p() {
      // non-zero-byte string -> true or false
      char* s = data_stack_pop();
      byte b = data_stack_pop();
      cell i = 0;
      while (s[i] != 0) {
        if (s[i] == b) {
          data_stack_push(true);
          return;
        }
        else {
          i++;
        }
      }
      data_stack_push(false);
    }
    #+end_src

*** p_string_find_byte

    #+begin_src c
    p_string_find_byte() {
      // byte string -> [index true] or [false]
      char* s = data_stack_pop();
      byte b = data_stack_pop();
      cell i = 0;
      while (s[i] != 0) {
        if (s[i] == b) {
          data_stack_push(i);
          data_stack_push(true);
          return;
        }
        else {
          i++;
        }
      }
      data_stack_push(false);
    }
    #+end_src

*** p_string_equal_p

    #+begin_src c
    p_string_equal_p() {
      data_stack_push(string_equal(data_stack_pop(), data_stack_pop()));
    }
    #+end_src

*** expose_string

    #+begin_src c
    expose_string() {
      define_prim("ins/string", i_int);
      define_primkey("string", k_string);
      define_primkey("one-string", k_one_string);
      define_prim("string/print", p_string_print);
      define_prim("string/dot", p_string_dot);
      define_prim("string/length", p_string_length);
      define_prim("string/append-to-buffer", p_string_append_to_buffer);
      define_prim("string/first-byte", p_string_first_byte);
      define_prim("string/last-byte", p_string_last_byte);
      define_prim("string/member?", p_string_member_p);
      define_prim("string/find-byte", p_string_find_byte);
      define_prim("string/equal?", p_string_equal_p);
    }
    #+end_src

* *file*

*** p_error_number_print

    #+begin_src c
    p_error_number_print() {
      // errno -> {terminal-output}
      int no = data_stack_pop();
      printf("%s", strerror(no));
    }
    #+end_src

*** p_path_open_read

    #+begin_src c
    p_path_open_read() {
      // [path] -> [file true] or [errno false]
      char* path = data_stack_pop();

      FILE* file = fopen(path, "r");
      if (file == NULL) {
        data_stack_push(errno);
        data_stack_push(false);
      }
      else {
        data_stack_push(file);
        data_stack_push(true);
      }
    }
    #+end_src

*** p_path_open_write

    #+begin_src c
    p_path_open_write() {
      // [path] -> [file true] or [errno false]
      char* path = data_stack_pop();

      FILE* file = fopen(path, "wx");
      if (file == NULL) {
        data_stack_push(errno);
        data_stack_push(false);
      }
      else {
        data_stack_push(file);
        data_stack_push(true);
      }
    }
    #+end_src

*** p_path_open_read_and_write

    #+begin_src c
    p_path_open_read_and_write() {
      // [path] -> [file true] or [errno false]
      char* path = data_stack_pop();

      FILE* file = fopen(path, "r+");
      if (file == NULL) {
        data_stack_push(errno);
        data_stack_push(false);
      }
      else {
        data_stack_push(file);
        data_stack_push(true);
      }
    }
    #+end_src

*** p_path_open_create

    #+begin_src c
    p_path_open_create() {
      // [path] -> [file true] or [errno false]
      char* path = data_stack_pop();

      FILE* file = fopen(path, "w+");
      if (file == NULL) {
        data_stack_push(errno);
        data_stack_push(false);
      }
      else {
        data_stack_push(file);
        data_stack_push(true);
      }
    }
    #+end_src

*** p_file_close

    #+begin_src c
    p_file_close() {
      // [file] -> [true] or [errno false]
      // - error reasons
      // 1. to close an unopened file descriptor
      // 2. close the same file descriptor twice
      // 3. error conditions for specific file system
      //    to diagnose during a close operation
      //    - for example, NFS (Network File System)
      FILE* file = data_stack_pop();

      if (fclose(file) == EOF) {
        data_stack_push(errno);
        data_stack_push(false);
      }
      else {
        data_stack_push(true);
      }
    }
    #+end_src

*** p_file_end_p

    #+begin_src c
    p_file_end_p() {
      // file -> true or false
      FILE* file = data_stack_pop();

      if (feof(file)) {
        data_stack_push(true);
      }
      else {
        data_stack_push(false);
      }
    }
    #+end_src

*** p_file_read

    #+begin_src c
    p_file_read() {
      // [file buffer requested-bytes] ->
      // [real-bytes true] or [errno false]
      // - partial read reasons
      //   1. [regular-file] end-of-file is reached
      //   2. [terminal] meets '\n'
      size_t want_bytes = data_stack_pop();
      void* buffer = data_stack_pop();
      FILE* file = data_stack_pop();

      size_t real_bytes = fread(buffer, 1, file, want_bytes);
      if (real_bytes != want_bytes) {
        if (ferror(file)) {
          data_stack_push(errno);
          data_stack_push(false);
        }
        else {
          data_stack_push(real_bytes);
          data_stack_push(true);
        }
      }
      else {
        data_stack_push(real_bytes);
        data_stack_push(true);
      }
    }
    #+end_src

*** p_file_write

    #+begin_src c
    p_file_write() {
      // [file buffer want-bytes] ->
      // [true] or [errno false]
      // - partial write reasons
      //   1. disk was filled
      //   2. the process resource limit on file sizes was reached
      size_t want_bytes = data_stack_pop();
      void* buffer = data_stack_pop();
      FILE* file = data_stack_pop();

      ssize_t real_bytes = fwrite(buffer, 1, want_bytes, file);
      if (real_bytes != want_bytes) {
        data_stack_push(errno);
        data_stack_push(false);
      }
      else {
        data_stack_push(true);
      }
    }
    #+end_src

*** p_file_size

    #+begin_src c
    p_file_size() {
      // file -> int
      FILE* file = data_stack_pop();
      struct stat file_state;
      fstat(fileno(file), &file_state);
      data_stack_push(file_state.st_size);
    }
    #+end_src

*** p_file_regular_file_p

    #+begin_src c
    p_file_regular_file_p() {
      // file -> true or false
      FILE* file = data_stack_pop();
      struct stat file_state;
      fstat(fileno(file), &file_state);
      if ((file_state.st_mode & S_IFMT) == S_IFREG) {
        data_stack_push(true);
      }
      else {
        data_stack_push(false);
      }
    }
    #+end_src

*** p_file_directory_p

    #+begin_src c
    p_file_directory_p() {
      // file -> true or false
      FILE* file = data_stack_pop();
      struct stat file_state;
      fstat(fileno(file), &file_state);
      if ((file_state.st_mode & S_IFMT) == S_IFDIR) {
        data_stack_push(true);
      }
      else {
        data_stack_push(false);
      }
    }
    #+end_src

*** p_file_character_device_p

    #+begin_src c
    p_file_character_device_p() {
      // file -> true or false
      FILE* file = data_stack_pop();
      struct stat file_state;
      fstat(fileno(file), &file_state);
      if ((file_state.st_mode & S_IFMT) == S_IFCHR) {
        data_stack_push(true);
      }
      else {
        data_stack_push(false);
      }
    }
    #+end_src

*** p_file_block_device_p

    #+begin_src c
    p_file_block_device_p() {
      // file -> true or false
      FILE* file = data_stack_pop();
      struct stat file_state;
      fstat(fileno(file), &file_state);
      if ((file_state.st_mode & S_IFMT) == S_IFBLK) {
        data_stack_push(true);
      }
      else {
        data_stack_push(false);
      }
    }
    #+end_src

*** p_file_fifo_p

    #+begin_src c
    p_file_fifo_p() {
      // file -> true or false
      FILE* file = data_stack_pop();
      struct stat file_state;
      fstat(fileno(file), &file_state);
      if ((file_state.st_mode & S_IFMT) == S_IFIFO) {
        data_stack_push(true);
      }
      else {
        data_stack_push(false);
      }
    }
    #+end_src

*** p_file_socket_p

    #+begin_src c
    p_file_socket_p() {
      // file -> true or false
      FILE* file = data_stack_pop();
      struct stat file_state;
      fstat(fileno(file), &file_state);
      if ((file_state.st_mode & S_IFMT) == S_IFSOCK) {
        data_stack_push(true);
      }
      else {
        data_stack_push(false);
      }
    }
    #+end_src

*** p_path_exist_p

    #+begin_src c
    p_path_exist_p() {
      // path -> true or false
      char* path = data_stack_pop();

      if (access(path, F_OK) == -1) {
        data_stack_push(false);
      }
      else {
        data_stack_push(true);
      }
    }
    #+end_src

*** p_path_readable_p

    #+begin_src c
    p_path_readable_p() {
      // path -> true or false
      char* path = data_stack_pop();

      if (access(path, R_OK) == -1) {
        data_stack_push(false);
      }
      else {
        data_stack_push(true);
      }
    }
    #+end_src

*** p_path_writable_p

    #+begin_src c
    p_path_writable_p() {
      // path -> true or false
      char* path = data_stack_pop();

      if (access(path, W_OK) == -1) {
        data_stack_push(false);
      }
      else {
        data_stack_push(true);
      }
    }
    #+end_src

*** p_path_executable_p

    #+begin_src c
    p_path_executable_p() {
      // path -> true or false
      char* path = data_stack_pop();

      if (access(path, X_OK) == -1) {
        data_stack_push(false);
      }
      else {
        data_stack_push(true);
      }
    }
    #+end_src

*** p_file_print_path

    #+begin_src c
    p_file_print_path() {
      // file -> path
      FILE* file = data_stack_pop();

      char proc_link_path[PATH_MAX];
      char file_path[PATH_MAX];

      sprintf(proc_link_path, "/proc/self/fd/%d", fileno(file));

      ssize_t real_bytes = readlink(proc_link_path, file_path, PATH_MAX);
      if (real_bytes == -1) {
        reportf("- p_file_print_path fail readlink /proc/self/fd/%d\n", fileno(file));
        perror("\n");
      }
      else {
        file_path[real_bytes] = '\0';
        printf("%s", file_path);
      }
    }
    #+end_src

*** p_path_load

    #+begin_src c
    p_repl();

    p_path_load() {
      // path -> {reading_stack}
      char* path = data_stack_pop();
      int file = open(path, O_RDONLY);
      if(file == -1) {
        reportf("- p_path_load fail : %s\n", path);
        perror("file open failed");
        return;
      }
      input_stack input_stack = input_stack_file(file);
      push(reading_stack, input_stack);
      p_repl();
      drop(reading_stack);
      input_stack_free(input_stack);
      close(file);
    }
    #+end_src

*** k_one_include

    #+begin_src c
    k_one_include() {
      // "..."
      char* path = malloc(PATH_MAX);
      cell cursor = 0;
      while (true) {
        char c = read_byte();
        if (c == '"') {
          path[cursor] = 0;
          cursor++;
          break;
        }
        else {
          path[cursor] = c;
          cursor++;
        }
      }
      char* real_read_path = get_real_reading_path(path);
      free(path);
      data_stack_push(real_read_path);
      p_path_load();
      free(real_read_path);
    }
    #+end_src

*** k_include

    #+begin_src c
    k_include() {
      // (include "..." ...)
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_KET) {
          return;
        }
        else if (s == ROUND_BAR) {
          jo_apply(read_jo());
        }
        else if (s == DOUBLE_QUOTE) {
          k_one_include();
        }
        else {
          // do nothing
        }
      }
    }
    #+end_src

*** expose_file

    #+begin_src c
    expose_file() {
      define_prim("error-number/print", p_error_number_print);

      define_prim("path/open/read", p_path_open_read);
      define_prim("path/open/write", p_path_open_write);
      define_prim("path/open/create", p_path_open_create);
      define_prim("path/open/read-and-write", p_path_open_read_and_write);

      define_prim("file/close", p_file_close);

      define_prim("file/read", p_file_read);
      define_prim("file/write", p_file_write);

      define_prim("file/size", p_file_size);

      define_prim("file/regular-file?", p_file_regular_file_p);
      define_prim("file/directory?", p_file_directory_p);
      define_prim("file/character-device?", p_file_character_device_p);
      define_prim("file/block-device?", p_file_block_device_p);
      define_prim("file/fifo?", p_file_fifo_p);
      define_prim("file/socket?", p_file_socket_p);

      define_prim("path/exist?", p_path_exist_p);
      define_prim("path/readable?", p_path_readable_p);
      define_prim("path/writable?", p_path_writable_p);
      define_prim("path/executable?", p_path_executable_p);

      define_prim("file/print-path", p_file_print_path);

      define_prim("path/load", p_path_load);
      define_primkey("include", k_include);
    }
    #+end_src

* *system*

*** p_command_run

    #+begin_src c
    p_command_run() {
      // string -> {*}
      system(data_stack_pop());
    }
    #+end_src

*** p_n_command_run

    #+begin_src c
    p_n_command_run() {
      // ... string n -> *
      cell n = data_stack_pop();
      cell i = 0;
      char* str = malloc(4 * 1024);
      str[0] = 0;
      while (i < n) {
        strcat(str, data_stack[data_stack_pointer - n + i]);
        i++;
      }
      data_stack_pointer = data_stack_pointer - n;
      system(str);
      free(str);
    }
    #+end_src

*** p_cmd_number

    #+begin_src c
    cell cmd_number;

    p_cmd_number() {
      // -> cmd_number
      data_stack_push(cmd_number);
    }
    #+end_src

*** p_index_to_cmd_string

    #+begin_src c
    char** cmd_string_array;

    p_index_to_cmd_string() {
      // index -> string
      cell index = data_stack_pop();
      char* cmd_string = cmd_string_array[index];
      data_stack_push(cmd_string);
    }
    #+end_src

*** p_find_env_string

    #+begin_src c
    p_find_env_string() {
      // string -> [env-string true] or [false]
      char* var_string = data_stack_pop();
      char* env_string = getenv(var_string);
      if (env_string == NULL) {
        data_stack_push(false);
      }
      else {
        data_stack_push(env_string);
        data_stack_push(true);
      }
    }
    #+end_src

*** expose_system

    #+begin_src c
    expose_system() {
      define_prim("command/run", p_command_run);
      define_prim("n-command/run", p_n_command_run);
      define_prim("cmd-number", p_cmd_number);
      define_prim("index->cmd-string", p_index_to_cmd_string);
      define_prim("find-env-string", p_find_env_string);
    }
    #+end_src

* *cffi*

*** ccall

    #+begin_src c
    ccall (char* function_name, void* lib) {
      primitive fun = dlsym(lib, function_name);
      if (fun == NULL) {
        reportf("- ccall fail\n");
        reportf("  function_name : %s\n", function_name);
        reportf("  dynamic link error : %s\n", dlerror());
      };
      fun();
    }
    #+end_src

*** k_clib_one

    #+begin_src c
    k_clib_one() {
      // "..."
      char* path = malloc(PATH_MAX);
      cell cursor = 0;
      while (true) {
        char c = read_byte();
        if (c == '"') {
          path[cursor] = 0;
          cursor++;
          break;
        }
        else {
          path[cursor] = c;
          cursor++;
        }
      }
      char* real_read_path = get_real_reading_path(path);
      free(path);
      void* lib = dlopen(real_read_path, RTLD_LAZY);
      if (lib == NULL) {
        reportf("- k_clib_one fail to open library\n");
        reportf("  real_read_path : %s\n", real_read_path);
        reportf("  dynamic link error : %s\n", dlerror());
        p_debug();
        return;
      };
      free(real_read_path);
      ccall("expose", lib);
    }
    #+end_src

*** k_clib

    #+begin_src c
    k_clib() {
      // (clib "..." ...)
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_KET) {
          return;
        }
        else if (s == DOUBLE_QUOTE) {
          k_clib_one();
        }
        else {
          // do nothing
        }
      }
    }
    #+end_src

*** expose_cffi

    #+begin_src c
    expose_cffi() {
      define_prim("clib", k_clib);
    }
    #+end_src

* *top_level*

*** k_define

    #+begin_src c
    k_run();

    k_define() {
      jo name = read_jo();
      k_run();
      data_stack_push(name);
      p_bind_name();
    }
    #+end_src

*** k_redefine

    #+begin_src c
    k_redefine() {
      jo name = read_jo();
      k_run();
      data_stack_push(name);
      p_rebind_name();
    }
    #+end_src

*** p_defined_p

    #+begin_src c
    p_defined_p() {
      // [name] -> true or false
      jo name = data_stack_pop();
      data_stack_push(used_jo_p(name));
    }
    #+end_src

*** k_declare

***** [note]

      - no compile before define
        declare helps mutual recursive function

***** k_declare_one

      #+begin_src c
      k_declare_one() {
        jo jo = read_jo();
        jo->tag = JO_DECLARED;
        k_ignore();
      }
      #+end_src

***** k_declare

      #+begin_src c
      k_declare() {
        while (true) {
          jo s = read_jo();
          if (s == ROUND_KET) {
            return;
          }
          else if (s == ROUND_BAR) {
            k_declare_one();
          }
          else {
            // do nothing
          }
        }
      }
      #+end_src

*** p_declared_p

    #+begin_src c
    p_declared_p() {
      // [name] -> true or false
      jo name = data_stack_pop();
      if (name->tag == JO_DECLARED) {
        data_stack_push(true);
      }
      else {
        data_stack_push(false);
      }
    }
    #+end_src

*** k_run

    #+begin_src c
    p_compile_jojo();

    k_run() {
      // (run ...)
      jo* jojo = tos(compiling_stack);
      p_compile_jojo();
      return_stack_new_point(jojo);
      eval();
    }
    #+end_src

*** k_test

    #+begin_src c
    bool test_flag = false;
    p_test_flag() { data_stack_push(test_flag); }
    p_test_flag_on() { test_flag = true; }
    p_test_flag_off() { test_flag = false; }

    k_test() {
      if (test_flag) {
        k_run();
      }
      else {
        k_ignore();
      }
    }
    #+end_src

*** p_repl

    #+begin_src c
    bool repl_flag = false;
    p_repl_flag() { data_stack_push(repl_flag); }
    p_repl_flag_on() { repl_flag = true; }
    p_repl_flag_off() { repl_flag = false; }

    p_repl() {
      while (true) {
        if (!has_jo_p()) {
          return 69;
        }
        jo s = read_jo();
        if (s == ROUND_BAR) {
          jo_apply(read_jo());
          if (repl_flag) {
            p_print_data_stack();
          }
        }
        else {
          // loop
        }
      }
    }
    #+end_src

*** p_bare_jojo_print

    #+begin_src c
    p_bare_jojo_print() {
      // jojo -> {terminal-output}
      jo* jojo = data_stack_pop();
      reportf("[ ");
      while (true) {
        if (jojo[0] == 0 && jojo[1] == 0) {
          break;
        }
        else if (jojo[0] == JO_INS_INT) {
          reportf("(int %ld) ", jojo[1]);
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_JO) {
          reportf("(jo %s) ", jo2str(jojo[1]));
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_STRING) {
          reportf("(string \"%s\") ", (char*)jojo[1]);
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_BYTE) {
          reportf("(btye \"%c\") ", (char)jojo[1]);
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_BARE_JOJO) {
          reportf("(bare-jojo ");
          data_stack_push(jojo + 2);
          p_bare_jojo_print();
          reportf(") ");
          jojo = jojo + (cell)jojo[1];
          jojo++;
        }
        else if (jojo[0] == JO_INS_ADDRESS) {
          reportf("(address %ld) ", jojo[1]);
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_JUMP_IF_FALSE) {
          reportf("(jump-if-false %ld) ", jojo[1]);
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_JUMP) {
          reportf("(jump %ld) ", jojo[1]);
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_LOOP) {
          reportf("(loop) ");
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_RECUR) {
          reportf("(recur) ");
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_TAIL_CALL) {
          reportf("(tail-call %s) ", jo2str(jojo[1]));
          jojo++;
          jojo++;
        }
        else {
          reportf("%s ", jo2str(jojo[0]));
          jojo++;
        }
      }
      reportf("] ");
    }
    #+end_src

*** point_return_point

    #+begin_src c
    point_return_point(cell i) {
      reportf("    - ");
      if (i != return_stack_pointer -1) {
        reportf("{ %s } ", jo2str(*(return_stack[i].jojo - 1)));
      }
      data_stack_push(return_stack[i].jojo);
      p_bare_jojo_print();
      reportf("\n");

    //   cell cursor = return_stack[i].local_pointer;
    //   cell end = return_stack[i+1].local_pointer;
    //   if (i = return_stack_pointer -1) {
    //     end = current_local_pointer;
    //   }

    //   while (end > cursor) {
    //     reportf("      %s = %ld %s\n"
    //            , jo2str(local_record[cursor].name)
    //            , local_record[cursor].local_data
    //            , jo2str(local_record[cursor].local_tag));
    //     cursor++;
    //   }
    }
    #+end_src

*** p_print_return_stack

    #+begin_src c
    p_print_return_stack() {
      cell i = return_stack_base;
      reportf("  - return-stack :\n");
      while (i < return_stack_pointer) {
        point_return_point(i);
        i++;
      }
    }
    #+end_src

*** p_debug_repl

    #+begin_src c
    cell debug_repl_level = 0;

    p_debug_repl() {
      while (true) {
        if (!has_jo_p()) {
          return;
        }
        jo jo = read_raw_jo();
        if (jo == str2jo("help")) {
          reportf("- debug-repl usage :\n");
          reportf("  - available commands :\n");
          reportf("    help exit bye\n");
        }
        else if (jo == str2jo("exit")) {
          return;
        }
        else if (jo == str2jo("bye")) {
          p_bye();
          return;
        }
        else if (jo == ROUND_BAR) {
          jo_apply(read_jo());
          p_print_data_stack();
          reportf("debug[%ld]> ", debug_repl_level);
        }
        else {
          // loop
        }
      }
    }
    #+end_src

*** p_debug

    #+begin_src c
    p_debug() {
      push(reading_stack, input_stack_terminal());

      reportf("- in debug-repl [level %ld] >_<!\n", debug_repl_level);
      p_print_return_stack();
      p_print_data_stack();
      reportf("debug[%ld]> ", debug_repl_level);
      debug_repl_level++;
      p_debug_repl();
      debug_repl_level--;
      reportf("- exit debug-repl [level %ld]\n", debug_repl_level);

      drop(reading_stack);
    }
    #+end_src

*** stepper

    #+begin_src c
    cell stepper_counter = 0;
    cell pending_steps = 0;

    // return will not exit stepper
    // set step_flag to exit stepper
    exit_stepper() {
      step_flag = false;
      stepper_counter = 0;
      pending_steps = 0;
      reportf("- exit stepper\n");
      drop(reading_stack);
    }

    stepper() {
      push(reading_stack, input_stack_terminal());
      reportf("stepper> ");
      while (true) {

        if (pending_steps > 0) {
          p_print_return_stack();
          p_print_data_stack();
          stepper_counter++;
          reportf("- stepper counting : %ld\n", stepper_counter);
          pending_steps--;
          return;
        }

        jo jo = read_raw_jo();
        if (jo == str2jo("help")) {
          reportf("- stepper usage :\n");
          reportf("  type '.' to execute one step\n");
          reportf("  type a numebr to execute the number of steps\n");
          reportf("  - available commands :\n");
          reportf("    help exit bye\n");
        }
        else if (jo == str2jo(".")) {
          p_print_return_stack();
          p_print_data_stack();
          stepper_counter++;
          reportf("- stepper counting : %ld\n", stepper_counter);
          return;
        }
        else if (nat_string_p(jo2str(jo))) {
          p_print_return_stack();
          p_print_data_stack();
          stepper_counter++;
          reportf("- stepper counting : %ld\n", stepper_counter);
          pending_steps = string_to_int(jo2str(jo)) - 1;
          return;
        }
        else if (jo == str2jo("exit")) {
          exit_stepper();
          return;
        }
        else if (jo == str2jo("bye")) {
          p_bye();
          return;
        }
        else {
          // loop
        }
      }
    }
    #+end_src

*** p_step

    #+begin_src c
    p_step() {
      step_flag = true;
    }
    #+end_src

*** to handle kernel signal

***** [note]

      - A function is said to be reentrant
        if it can safely be simultaneously executed
        by multiple threads of execution in the same process.
        In this context, safe means that
        the function achieves its expected result,
        regardless of the state of execution
        of any other thread of execution.

        Because a signal handler may asynchronously interrupt
        the execution of a program at any point in time,
        the main program and the signal handler
        in effect form two independent
        (although not concurrent) threads of execution
        within the same process.

        -- quote from (2010) (michael kerrisk) the linux programming interface

      - thus single handler must be reentrant.

      - since nonreentrant functions in many C libraries [specially stdio],
        and we can call such functions in the debug repl of jojo,
        we should not simply call the debug repl in the kernel_signal_handler.

      - but except introducing runtime overhead,
        I can think of not solutions to this problem.

        thus, after exited the debug repl,
        possibly unnecessary errors that induced by nonreentrant functions,
        might lead you into the debug repl again.

        thus, the debug repl is not reliable to enable you
        to recover from any errors which trigger kernel signal.
        [the debug repl can only debug them.]

***** kernel_signal_handler

      #+begin_src c
      kernel_signal_handler(int sig, siginfo_t *siginfo, void *ucontext) {
        fflush(stdin);
        fflush(stdout);
        fflush(stderr);

        reportf("- kernel_signal_handler\n");
        psiginfo(siginfo, "  signal ");

        int errno_backup;
        errno_backup = errno;

        p_debug();

        errno = errno_backup;
      }
      #+end_src

***** init_kernel_signal_handler

      #+begin_src c
      init_kernel_signal_handler() {
        struct sigaction kernel_signal_action;

        sigemptyset(&kernel_signal_action.sa_mask);

        kernel_signal_action.sa_flags = SA_SIGINFO | SA_NODEFER | SA_RESTART;
        kernel_signal_action.sa_sigaction = kernel_signal_handler;

        int sig_array[] = { SIGSEGV, SIGBUS, SIGFPE, SIGILL,
                            SIGPIPE, SIGSYS, SIGXCPU, SIGXFSZ};
        int sig_array_length = sizeof(sig_array)/sizeof(sig_array[0]);
        cell i = 0;
        while (i < sig_array_length) {
          if (sigaction(sig_array[i], &kernel_signal_action, NULL) == -1) {
            perror("- init_kernel_signal_handler fail");
          }
          i++;
        }
      }
      #+end_src

*** expose_top_level

    #+begin_src c
    expose_top_level() {
      define_primkey("define", k_define);
      define_primkey("redefine", k_redefine);
      define_prim("defined?", p_defined_p);

      define_primkey("declare", k_declare);
      define_prim("declared?", p_declared_p);

      define_primkey("run", k_run);

      define_primkey("test", k_test);
      define_prim("test-flag", p_test_flag);
      define_prim("test-flag/on", p_test_flag_on);
      define_prim("test-flag/off", p_test_flag_off);

      define_prim("repl", p_repl);
      define_prim("repl-flag", p_repl_flag);
      define_prim("repl-flag/on", p_repl_flag_on);
      define_prim("repl-flag/off", p_repl_flag_off);

      define_prim("bare-jojo/print", p_bare_jojo_print);
      define_prim("print-return-stack", p_print_return_stack);
      define_prim("debug", p_debug);

      define_prim("step", p_step);
    }
    #+end_src

* *keyword*

*** k_ignore

    #+begin_src c
    k_ignore() {
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_BAR) {
          k_ignore();
        }
        if (s == ROUND_KET) {
          break;
        }
      }
    }
    #+end_src

*** compile_until_meet_jo

    #+begin_src c
    compile_until_meet_jo(jo ending_jo) {
      while (true) {
        jo jo = read_jo();
        if (jo == ROUND_BAR) {
          jo_apply(read_jo());
        }
        else if (jo == ending_jo) {
          break;
        }
        else if (used_jo_p(jo)) {
          here(jo);
        }
        else {
          // no compile before define
          reportf("- compile_until_meet_jo undefined : %s\n", jo2str(jo));
          k_ignore();
          p_debug();
          return;
        }
      }
    }
    #+end_src

*** p_compile_until_meet_jo

    #+begin_src c
    p_compile_until_meet_jo() {
      compile_until_meet_jo(data_stack_pop());
    }
    #+end_src

*** compile_until_meet_jo_or_jo

    #+begin_src c
    jo compile_until_meet_jo_or_jo(jo ending_jo1, jo ending_jo2) {
      while (true) {
        jo jo = read_jo();
        if (jo == ROUND_BAR) {
          jo_apply(read_jo());
        }
        else if (jo == ending_jo1 || jo == ending_jo2) {
          return jo;
        }
        else if (used_jo_p(jo)) {
          here(jo);
        }
        else {
          // no compile before define
          reportf("- compile_until_meet_jo_or_jo undefined : %s\n", jo2str(jo));
          reportf("- ending_jo1 : %s\n", jo2str(ending_jo1));
          reportf("- ending_jo2 : %s\n", jo2str(ending_jo2));
          k_ignore();
          p_debug();
          return JO_NULL; // to fool the compiler
        }
      }
    }
    #+end_src

*** p_compile_until_round_ket

    #+begin_src c
    p_compile_until_round_ket() {
      compile_until_meet_jo(ROUND_KET);
    }
    #+end_src

*** i_jump

    #+begin_src c
    i_jump() {
      // {return_stack}
      return_point rp = return_stack_tos();
      jo* jojo = rp.jojo;
      cell offset = jojo[0];
      return_point rp1 = return_stack_pop();
      return_stack_make_point(jojo + offset, rp1.local_pointer);
    }
    #+end_src

*** k_jump

    #+begin_src c
    k_jump() {
      here(JO_INS_JUMP);
      here(string_to_int(jo2str(read_raw_jo())));
      k_ignore();
    }
    #+end_src

*** i_jump_if_false

    #+begin_src c
    i_jump_if_false() {
      // [bool] -> {return_stack}
      return_point rp = return_stack_tos();
      return_stack_inc();
      jo* jojo = rp.jojo;
      cell offset = jojo[0];
      cell b = data_stack_pop();
      if (b == false) {
        return_point rp1 = return_stack_pop();
        return_stack_make_point(jojo + offset, rp1.local_pointer);
      }
    }
    #+end_src

*** k_jump_if_false

    #+begin_src c
    k_jump_if_false() {
      here(JO_INS_JUMP_IF_FALSE);
      here(string_to_int(jo2str(read_raw_jo())));
      k_ignore();
    }
    #+end_src

*** k_if

    #+begin_src c
    // - without else
    //   (if a b p? then c d)
    //   ==>
    //     a b p?
    //     jump_if_false[:end-of-then]
    //     c d
    //   :end-of-then

    // - with else
    //   (if a b p? then c d else e f)
    //   ==>
    //     a b p?
    //     jump_if_false[:end-of-then]
    //     c d
    //     jump[:end-of-else]
    //   :end-of-then
    //     e f
    //   :end-of-else

    k_if() {
      compile_until_meet_jo(JO_THEN);
      here(JO_INS_JUMP_IF_FALSE);
      jo* end_of_then = tos(compiling_stack);
      p_compiling_stack_inc();
      jo ending_jo = compile_until_meet_jo_or_jo(JO_ELSE, ROUND_KET);
      if (ending_jo == ROUND_KET) {
        end_of_then[0] = (jo*)tos(compiling_stack) - end_of_then;
        return;
      }
      else {
        here(JO_INS_JUMP);
        jo* end_of_else = tos(compiling_stack);
        p_compiling_stack_inc();
        end_of_then[0] = (jo*)tos(compiling_stack) - end_of_then;
        p_compile_until_round_ket();
        end_of_else[0] = (jo*)tos(compiling_stack) - end_of_else;
        return;
      }
    }
    #+end_src

*** current_compiling_jojo_stack

    #+begin_src c
    stack current_compiling_jojo_stack; // of jo
    #+end_src

*** p_compile_jojo

    #+begin_src c
    p_compile_jojo() {
      jo* jojo = tos(compiling_stack);
      push(current_compiling_jojo_stack, jojo);
      compile_until_meet_jo(ROUND_KET);
      here(JO_END);
      here(0);
      here(0);
      drop(current_compiling_jojo_stack);
    }
    #+end_src

*** i_tail_call

    #+begin_src c
    i_tail_call() {
      return_point rp = return_stack_pop();
      jo* jojo = rp.jojo;
      jo jo = jojo[0];
      jo_apply_with_local_pointer(jo, rp.local_pointer);
    }
    #+end_src

*** k_tail_call

    #+begin_src c
    k_tail_call() {
      // no check for "no compile before define"
      here(JO_INS_TAIL_CALL);
      here(read_jo());
      k_ignore();
    }
    #+end_src

*** i_loop

    #+begin_src c
    i_loop() {
      return_point rp = return_stack_pop();
      jo* jojo = rp.jojo;
      jo* jojo_self = jojo[0];
      return_stack_make_point(jojo_self, rp.local_pointer);
    }
    #+end_src

*** k_loop

    #+begin_src c
    k_loop() {
      here(JO_INS_LOOP);
      here(tos(current_compiling_jojo_stack));
      k_ignore();
    }
    #+end_src

*** i_recur

    #+begin_src c
    i_recur() {
      return_point rp = return_stack_tos();
      return_stack_inc();
      jo* jojo = rp.jojo;
      jo* jojo_self = jojo[0];
      return_stack_new_point(jojo_self);
    }
    #+end_src

*** k_recur

    #+begin_src c
    k_recur() {
      here(JO_INS_RECUR);
      here(tos(current_compiling_jojo_stack));
      k_ignore();
    }
    #+end_src

*** p_compiling_stack_tos

    #+begin_src c
    p_compiling_stack_tos() {
      data_stack_push(tos(compiling_stack));
    }
    #+end_src

*** i_bare_jojo

    #+begin_src c
    i_bare_jojo() {
      return_point rp = return_stack_pop();
      jo* jojo = rp.jojo;
      cell offset = jojo[0];
      return_point rp1 = {.jojo = jojo + offset,
                          .local_pointer = rp.local_pointer};
      return_stack_push(rp1);
      data_stack_push(jojo + 1);
    }
    #+end_src

*** k_bare_jojo

    #+begin_src c
    k_bare_jojo() {
      // (bare-jojo ...)
      here(JO_INS_BARE_JOJO);
      jo* beginning = tos(compiling_stack);
      p_compiling_stack_inc();
      p_compile_jojo();
      beginning[0] = (jo*)tos(compiling_stack) - beginning;
    }
    #+end_src

*** k_jojo

    #+begin_src c
    k_jojo() {
      // (jojo ...)
      k_bare_jojo();
      here(JO_INS_JO);
      here(TAG_JOJO);
    }
    #+end_src

*** k_keyword

    #+begin_src c
    k_keyword() {
      // (keyword ...)
      k_bare_jojo();
      here(JO_INS_JO);
      here(TAG_KEYWORD);
    }
    #+end_src

*** k_data

    - the semantic of this keyword has limitation,
      there can be not 'end' in it.

    #+begin_src c
    k_data() {
      // (data ...)
      p_compile_until_round_ket();
      here(JO_INS_JO);
      here(TAG_DATA);
    }
    #+end_src

*** local_find

    #+begin_src c
    cell local_find(jo name) {
      // return index of local_record
      // -1 -- no found
      return_point rp = return_stack_tos();
      cell cursor = current_local_pointer - 1;
      while (cursor >= rp.local_pointer) {
        if (local_record[cursor].name == name) {
          return cursor;
        }
        else {
          cursor--;
        }
      }
      return -1;
    }
    #+end_src

*** p_local_data_in

    #+begin_src c
    p_local_data_in() {
      cell jo = data_stack_pop();
      cell index = local_find(jo);
      cell data = data_stack_pop();
      if (index != -1) {
        local_record[index].name = jo;
        local_record[index].local_data = data;
      }
      else {
        local_record[current_local_pointer].name = jo;
        local_record[current_local_pointer].local_data = data;
        current_local_pointer = current_local_pointer + 1;
      }
    }
    #+end_src

*** p_local_data_out

    #+begin_src c
    p_local_data_out() {
      cell jo = data_stack_pop();
      cell index = local_find(jo);
      if (index != -1) {
        local_point lp = local_record[index];
        data_stack_push(lp.local_data);
      }
      else {
        reportf("- p_local_data_out fatal error\n");
        reportf("  name is not bound\n");
        reportf("  name : %s\n", jo2str(jo));
        p_debug();
      }
    }
    #+end_src

*** p_local_tag_in

    #+begin_src c
    p_local_tag_in() {
      cell jo = data_stack_pop();
      cell index = local_find(jo);
      cell tag = data_stack_pop();
      if (index != -1) {
        local_record[index].name = jo;
        local_record[index].local_tag = tag;
      }
      else {
        local_record[current_local_pointer].name = jo;
        local_record[current_local_pointer].local_tag = tag;
        current_local_pointer = current_local_pointer + 1;
      }
    }
    #+end_src

*** p_local_tag_out

    #+begin_src c
    p_local_tag_out() {
      cell jo = data_stack_pop();
      cell index = local_find(jo);
      if (index != -1) {
        local_point lp = local_record[index];
        data_stack_push(lp.local_tag);
      }
      else {
        reportf("- p_local_tag_out fatal error\n");
        reportf("  name is not bound\n");
        reportf("  name : %s\n", jo2str(jo));
        p_debug();
      }
    }
    #+end_src

*** p_local_in

    #+begin_src c
    p_local_in() {
      cell jo = data_stack_pop();
      cell index = local_find(jo);
      cell tag = data_stack_pop();
      cell data = data_stack_pop();
      if (index != -1) {
        local_record[index].name = jo;
        local_record[index].local_tag = tag;
        local_record[index].local_data = data;
      }
      else {
        local_record[current_local_pointer].name = jo;
        local_record[current_local_pointer].local_tag = tag;
        local_record[current_local_pointer].local_data = data;
        current_local_pointer = current_local_pointer + 1;
      }
    }
    #+end_src

*** p_local_out

    #+begin_src c
    p_local_out() {
      cell jo = data_stack_pop();
      cell index = local_find(jo);
      if (index != -1) {
        local_point lp = local_record[index];
        data_stack_push(lp.local_data);
        data_stack_push(lp.local_tag);
      }
      else {
        reportf("- p_local_out fatal error\n");
        reportf("  name is not bound\n");
        reportf("  name : %s\n", jo2str(jo));
        p_debug();
      }
    }
    #+end_src

*** k_local_data_in

    #+begin_src c
    k_local_data_in() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        k_local_data_in();

        here(JO_INS_JO);
        here(s);
        here(JO_LOCAL_DATA_IN);
      }
    }
    #+end_src

*** k_local_data_out

    #+begin_src c
    k_local_data_out() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        here(JO_INS_JO);
        here(s);
        here(JO_LOCAL_DATA_OUT);

        k_local_data_out();
      }
    }
    #+end_src

*** k_local_tag_in

    #+begin_src c
    k_local_tag_in() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        k_local_data_in();

        here(JO_INS_JO);
        here(s);
        here(JO_LOCAL_TAG_IN);
      }
    }
    #+end_src

*** k_local_tag_out

    #+begin_src c
    k_local_tag_out() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        here(JO_INS_JO);
        here(s);
        here(JO_LOCAL_TAG_OUT);

        k_local_data_out();
      }
    }
    #+end_src

*** k_local_in

    #+begin_src c
    k_local_in() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        k_local_data_in();

        here(JO_INS_JO);
        here(s);
        here(JO_LOCAL_IN);
      }
    }
    #+end_src

*** k_local_out

    #+begin_src c
    k_local_out() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        here(JO_INS_JO);
        here(s);
        here(JO_LOCAL_OUT);

        k_local_data_out();
      }
    }
    #+end_src

*** p_current_local_pointer

    #+begin_src c
    p_current_local_pointer() {
      data_stack_push(current_local_pointer);
    }
    #+end_src

*** expose_keyword

    #+begin_src c
    expose_keyword() {
      define_primkey("ignore", k_ignore);
      define_primkey("note", k_ignore);

      define_prim("compiling-stack/tos", p_compiling_stack_tos);
      define_prim("compiling-stack/inc", p_compiling_stack_inc);

      define_prim("compile-until-meet-jo", p_compile_until_meet_jo);
      define_prim("compile-until-round-ket", p_compile_until_round_ket);


      define_prim("ins/jump", i_jump);
      define_primkey("jump", k_jump);

      define_prim("ins/jump-if-false", i_jump_if_false);
      define_primkey("jump-if-false", k_jump_if_false);

      define_primkey("if", k_if);
      define_primkey("else", p_compile_until_round_ket);
      define_primkey("el", p_compile_until_round_ket);

      define_prim("compile-jojo", p_compile_jojo);

      define_prim("ins/tail-call", i_tail_call);
      define_primkey("tail-call", k_tail_call);
      define_prim("ins/loop", i_loop);
      define_primkey("loop", k_loop);
      define_prim("ins/recur", i_recur);
      define_primkey("recur", k_recur);

      define_primkey("data", k_data);
      define_primkey("jojo", k_jojo);
      define_primkey("keyword", k_keyword);

      define_prim("ins/bare-jojo", i_bare_jojo);
      define_primkey("bare-jojo", k_bare_jojo);

      define_prim("local-data-in", p_local_data_in);
      define_prim("local-data-out", p_local_data_out);
      define_primkey(">", k_local_data_in);
      define_primkey("<", k_local_data_out);

      define_prim("local-tag-in", p_local_tag_in);
      define_prim("local-tag-out", p_local_tag_out);
      define_primkey("%>", k_local_tag_in);
      define_primkey("<%", k_local_tag_out);

      define_prim("local-in", p_local_in);
      define_prim("local-out", p_local_out);
      define_primkey(">>", k_local_in);
      define_primkey("<<", k_local_out);

      define_prim("current-local-pointer", p_current_local_pointer);
    }
    #+end_src

* *misc*

*** p_here

    #+begin_src c
    p_here() {
      here(data_stack_pop());
    }
    #+end_src

*** bar and ket

    #+begin_src c
    p_round_bar()    { data_stack_push(ROUND_BAR); }
    p_round_ket()    { data_stack_push(ROUND_KET); }
    p_square_bar()   { data_stack_push(SQUARE_BAR); }
    p_square_ket()   { data_stack_push(SQUARE_KET); }
    p_flower_bar()   { data_stack_push(FLOWER_BAR); }
    p_flower_ket()   { data_stack_push(FLOWER_KET); }
    p_double_quote() { data_stack_push(DOUBLE_QUOTE); }
    #+end_src

*** p_cell_size

    #+begin_src c
    p_cell_size() {
      data_stack_push(sizeof(cell));
    }
    #+end_src

*** p_newline

    #+begin_src c
    p_newline() {
      printf("\n");
    }
    #+end_src

*** expose_mise

    #+begin_src c
    expose_mise() {
      define_prim("here", p_here);

      define_prim("round-bar", p_round_bar);
      define_prim("round-ket", p_round_ket);
      define_prim("square-bar", p_square_bar);
      define_prim("square-ket", p_square_ket);
      define_prim("flower-bar", p_flower_bar);
      define_prim("flower-ket", p_flower_ket);
      define_prim("double-quote", p_double_quote);

      define_prim("cell-size", p_cell_size);

      define_prim("newline", p_newline);
    }
    #+end_src

* *play*

*** p1

    #+begin_src c
    p1() {
      int file = open("README", O_RDWR);
      input_stack t0_stack = input_stack_file(file);
      input_stack_push(t0_stack, '\n');
      input_stack_push(t0_stack, '\n');
      input_stack_push(t0_stack, '1');
      input_stack_push(t0_stack, '2');
      input_stack_push(t0_stack, '3');
      input_stack_push(t0_stack, '4');
      input_stack_push(t0_stack, '\n');
      input_stack_push(t0_stack, '\n');
      while (!input_stack_empty_p(t0_stack)) {
        reportf("%c", input_stack_pop(t0_stack));
      }
      input_stack_free(t0_stack);
      reportf("- input_stack test0 finished\n");

      input_stack t1_stack = input_stack_terminal();
      while (!input_stack_empty_p(t1_stack)) {
        byte byte = input_stack_pop(t1_stack);
        reportf("\n> %c", byte);
      }
      input_stack_free(t1_stack);
      reportf("- input_stack test1 finished\n");

      input_stack t2_stack = input_stack_string("1234567890");
      input_stack_push(t2_stack, '\n');
      input_stack_push(t2_stack, '\n');
      input_stack_push(t2_stack, '1');
      input_stack_push(t2_stack, '2');
      input_stack_push(t2_stack, '3');
      input_stack_push(t2_stack, '4');
      input_stack_push(t2_stack, '\n');
      input_stack_push(t2_stack, '\n');
      while (!input_stack_empty_p(t2_stack)) {
        byte byte = input_stack_pop(t2_stack);
        reportf("%c", byte);
      }
      input_stack_free(t2_stack);
      reportf("\n");
      reportf("- input_stack test2 finished\n");
    }
    #+end_src

*** p2

    #+begin_src c
    p2() {
      int file = open("k1~", O_RDWR);
      output_stack t0_stack = output_stack_file(file);
      output_stack_push(t0_stack, '1'); output_stack_pop(t0_stack);
      output_stack_push(t0_stack, '2');
      output_stack_push(t0_stack, '3'); output_stack_drop(t0_stack);
      output_stack_push(t0_stack, '4');
      output_stack_push(t0_stack, '\n');
      output_stack_file_flush(t0_stack);
      output_stack_push(t0_stack, '1');
      output_stack_push(t0_stack, '2'); output_stack_pop(t0_stack);
      output_stack_push(t0_stack, '3');
      output_stack_push(t0_stack, '4'); output_stack_drop(t0_stack);
      output_stack_push(t0_stack, '\n');
      output_stack_file_flush(t0_stack);
      output_stack_free(t0_stack);
      close(file);
      reportf("- output_stack test0 finished\n");

      output_stack t1_stack = output_stack_terminal();
      output_stack_push(t1_stack, '\n');
      output_stack_push(t1_stack, '\n');
      output_stack_push(t1_stack, '1');
      output_stack_push(t1_stack, '2');
      output_stack_push(t1_stack, '3');
      output_stack_push(t1_stack, '4');
      output_stack_push(t1_stack, '\n');
      output_stack_push(t1_stack, '\n');
      output_stack_free(t1_stack);
      reportf("- output_stack test1 finished\n");

      output_stack t2_stack = output_stack_string();
      output_stack_push(t2_stack, '1');
      output_stack_push(t2_stack, '2');
      reportf("- %c\n", output_stack_pop(t2_stack));
      output_stack_push(t2_stack, '3');
      output_stack_push(t2_stack, '4');
      reportf("- %c\n", output_stack_pop(t2_stack));
      output_stack_push(t2_stack, '\n');
      char* collected_string = output_stack_string_collect(t2_stack);
      reportf("- collected_string : %s\n", collected_string);
      output_stack_free(t2_stack);
      reportf("- output_stack test2 finished\n");
    }
    #+end_src

*** init_play

    #+begin_src c
    init_play() {
    }
    #+end_src

*** expose_play

    #+begin_src c
    expose_play() {
      define_prim("p1", p1);
      define_prim("p2", p2);
    }
    #+end_src

* init

*** init_jotable

    #+begin_src c
    init_jotable() {
      bzero(jotable, jotable_size * sizeof(jotable_entry));
    }
    #+end_src

*** init_literal_jo

    #+begin_src c
    init_literal_jo() {
      EMPTY_JO = str2jo("");

      TAG_PRIM         = str2jo("<prim>");
      TAG_JOJO         = str2jo("<jojo>");
      TAG_PRIM_KEYWORD = str2jo("<prim-keyword>");
      TAG_KEYWORD      = str2jo("<keyword>");
      TAG_DATA         = str2jo("<data>");

      JO_DECLARED = str2jo("declared");

      ROUND_BAR    =   str2jo("(");
      ROUND_KET    =   str2jo(")");
      SQUARE_BAR   =   str2jo("[");
      SQUARE_KET   =   str2jo("]");
      FLOWER_BAR   =   str2jo("{");
      FLOWER_KET   =   str2jo("}");
      DOUBLE_QUOTE =   str2jo("\"");

      JO_INS_INT  = str2jo("ins/int");
      JO_INS_JO   = str2jo("ins/jo");
      JO_INS_STRING = str2jo("ins/string");
      JO_INS_BYTE = str2jo("ins/byte");
      JO_INS_BARE_JOJO = str2jo("ins/bare-jojo");
      JO_INS_ADDRESS = str2jo("ins/address");

      JO_INS_JUMP = str2jo("ins/jump");
      JO_INS_JUMP_IF_FALSE = str2jo("ins/jump-if-false");

      JO_INS_TAIL_CALL = str2jo("ins/tail-call");
      JO_INS_LOOP = str2jo("ins/loop");
      JO_INS_RECUR = str2jo("ins/recur");

      JO_NULL     = str2jo("null");
      JO_THEN     = str2jo("then");
      JO_ELSE     = str2jo("else");

      JO_APPLY     = str2jo("apply");
      JO_END       = str2jo("end");

      JO_LOCAL_DATA_IN = str2jo("local-data-in");
      JO_LOCAL_DATA_OUT = str2jo("local-data-out");

      JO_LOCAL_TAG_IN = str2jo("local-tag-in");
      JO_LOCAL_TAG_OUT = str2jo("local-tag-out");

      JO_LOCAL_IN = str2jo("local-in");
      JO_LOCAL_OUT = str2jo("local-out");
    }
    #+end_src

*** init_stacks

    #+begin_src c
    jo jojo_area[1024 * 1024];

    init_stacks() {
      compiling_stack              = new_stack("compiling_stack");
      reading_stack                = new_stack("reading_stack");
      binding_filter_stack         = new_stack("binding_filter_stack");
      keyword_stack                = new_stack("keyword_stack");
      jo_filter_stack              = new_stack("jo_filter_stack");
      current_compiling_jojo_stack = new_stack("current_compiling_jojo_stack");

      push(compiling_stack, jojo_area);
      push(reading_stack, input_stack_terminal());
      push(jo_filter_stack, str2jo("alias-filter"));
    }
    #+end_src

*** init_jojo

    #+begin_src c
    init_jojo() {
      init_jotable();
      init_literal_jo();
      init_stacks();
      init_kernel_signal_handler();

      p_empty_jo();
      p_drop();

      expose_name();
      expose_apply();
      expose_stack_operation();
      expose_ending();
      expose_bool();
      expose_int();
      expose_memory();
      expose_byte();
      expose_jo();
      expose_string();
      expose_file();
      expose_keyword();
      expose_system();
      expose_cffi();
      expose_top_level();
      expose_mise();

      expose_play();
    }
    #+end_src

*** init_core

    #+begin_src c
    #include "core/0.0.1/core.h"

    init_core() {
      input_stack input_stack = input_stack_string(core_0_0_1_core_jo);
      push(reading_stack, input_stack);
      p_repl();
      drop(reading_stack);
      input_stack_free(input_stack);
    }
    #+end_src

* main

  #+begin_src c
  int main(int argc, char** argv) {
    cmd_number = argc;
    cmd_string_array = argv;
    init_jojo();
    init_core();
    init_play();
    return p_repl();
  }
  #+end_src
